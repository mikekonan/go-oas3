package generator

import (
	"encoding/json"
	"fmt"
	"html"
	"strings"

	"github.com/ahmetb/go-linq"
	"github.com/dave/jennifer/jen"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/spf13/cast"
	"github.com/tdewolff/minify/v2/minify"

	"github.com/mikekonan/go-oas3/configurator"
)

type Generator struct {
	normalizer *Normalizer          `di.inject:"normalizer"`
	typee      *Type                `di.inject:"typeFiller"`
	config     *configurator.Config `di.inject:"config"`
}

type Result struct {
	ComponentsCode *jen.File
	RouterCode     *jen.File
}

func (generator *Generator) file(from jen.Code, packagePath string) *jen.File {
	file := jen.NewFilePathName(packagePath, generator.trimPackagePath(packagePath))
	file.HeaderComment("This file is generated by github.com/mikekonan/go-oas3. DO NOT EDIT.")
	file.ImportAlias("github.com/mikekonan/go-countries", "countries")
	file.ImportAlias("github.com/mikekonan/go-currencies", "currency")

	file.Add(from)

	return file
}

func (generator *Generator) Generate(swagger *openapi3.Swagger) *Result {
	componentsAdditionalVars, parametersAdditionalVars := generator.additionalConstants(swagger)

	componentsCode := jen.Null().Add(componentsAdditionalVars, generator.components(swagger))
	routerCode := jen.Null().
		Add(parametersAdditionalVars...).Line().
		Add(generator.wrappers(swagger)).Line().
		Add(generator.requestResponseBuilders(swagger)).Line().
		Add(generator.specCode(swagger)).Line().
		Add(generator.securitySchemas(swagger))

	return &Result{
		ComponentsCode: generator.file(componentsCode, generator.config.ComponentsPackage),
		RouterCode:     generator.file(routerCode, generator.config.Package),
	}
}

func (generator *Generator) requestParameters(paths map[string]*openapi3.PathItem) jen.Code {
	var result []jen.Code

	linq.From(paths).
		SelectManyT(func(kv linq.KeyValue) linq.Query {
			path := cast.ToString(kv.Key)
			operationsCodeTags := map[string][]jen.Code{}

			linq.From(kv.Value.(*openapi3.PathItem).Operations()).
				GroupByT(
					func(kv linq.KeyValue) string { return kv.Value.(*openapi3.Operation).Tags[0] },
					func(kv linq.KeyValue) (result []jen.Code) {
						name := generator.normalizer.normalizeOperationName(path, cast.ToString(kv.Key))
						operation := kv.Value.(*openapi3.Operation)
						if operation.RequestBody == nil {
							result = append(result, generator.requestParameterStruct(name, "", false, operation))
							return
						}

						if operation.RequestBody != nil && len(operation.RequestBody.Value.Content) == 1 {
							contentType := cast.ToString(linq.From(operation.RequestBody.Value.Content).SelectT(func(kv linq.KeyValue) string { return cast.ToString(kv.Key) }).First())
							result = append(result, generator.requestParameterStruct(name, contentType, false, operation))
							return
						}

						var contentTypeResult []jen.Code
						linq.From(operation.RequestBody.Value.Content).
							SelectT(func(kv linq.KeyValue) jen.Code { return generator.requestParameterStruct(name, cast.ToString(kv.Key), true, operation) }).
							ToSlice(&contentTypeResult)

						result = append(result, contentTypeResult...)

						result = generator.normalizer.doubleLineAfterEachElement(result...)

						return
					},
				).
				ToMapByT(&operationsCodeTags,
					func(kv linq.Group) interface{} { return kv.Key },
					func(kv linq.Group) (grouped []jen.Code) {
						linq.From(kv.Group).SelectMany(func(i interface{}) linq.Query { return linq.From(i) }).ToSlice(&grouped)
						return
					},
				)

			return linq.From(operationsCodeTags)
		}).
		GroupByT(
			func(kv linq.KeyValue) interface{} { return kv.Key },
			func(kv linq.KeyValue) interface{} { return kv.Value },
		).
		SelectT(func(kv linq.Group) jen.Code {
			var grouped []jen.Code
			linq.From(kv.Group).SelectMany(func(i interface{}) linq.Query { return linq.From(i) }).ToSlice(&grouped)
			return jen.Add(generator.normalizer.lineAfterEachElement(grouped...)...)
		}).
		ToSlice(&result)

	return jen.Null().
		Add(result...).
		Add(jen.Line())
}

func (generator *Generator) components(swagger *openapi3.Swagger) jen.Code {
	var componentsResult []jen.Code

	linq.From(swagger.Components.Schemas).
		WhereT(func(kv linq.KeyValue) bool { return len(kv.Value.(*openapi3.SchemaRef).Value.Enum) == 0 }). //filter enums
		SelectT(func(kv linq.KeyValue) jen.Code {
			schemaRef := kv.Value.(*openapi3.SchemaRef)
			return generator.componentFromSchema(cast.ToString(kv.Key), schemaRef)
		},
		).ToSlice(&componentsResult)

	var componentsFromPathsResult []jen.Code

	linq.From(swagger.Paths).
		SelectManyT(func(kv linq.KeyValue) linq.Query {
			path := cast.ToString(kv.Key)
			componentsByName := map[string]jen.Code{}

			linq.From(kv.Value.(*openapi3.PathItem).Operations()).
				WhereT(func(kv linq.KeyValue) bool {
					operation := kv.Value.(*openapi3.Operation)
					return operation.RequestBody != nil && len(operation.RequestBody.Value.Content) > 0 &&
						linq.From(operation.RequestBody.Value.Content).
							AnyWithT(func(kv linq.KeyValue) bool { return kv.Value.(*openapi3.MediaType).Schema.Ref == "" })
				}).
				SelectManyT(
					func(kv linq.KeyValue) linq.Query {
						result := map[string]jen.Code{}
						name := generator.normalizer.normalizeOperationName(path, cast.ToString(kv.Key))
						operation := kv.Value.(*openapi3.Operation)

						if len(operation.RequestBody.Value.Content) == 1 {
							name += "RequestBody"
							obj := linq.From(operation.RequestBody.Value.Content).SelectT(func(kv linq.KeyValue) interface{} { return kv.Value }).First().(*openapi3.MediaType)

							result[name] = generator.componentFromSchema(name, obj.Schema)
							return linq.From(result)
						}

						linq.From(operation.RequestBody.Value.Content).
							ToMapByT(&result,
								func(kv linq.KeyValue) string { return name + generator.normalizer.contentType(cast.ToString(kv.Key)+"RequestBody") },
								func(kv linq.KeyValue) jen.Code {
									meType := kv.Value.(*openapi3.MediaType)

									objName := name + generator.normalizer.contentType(cast.ToString(kv.Key)+"RequestBody")
									return generator.componentFromSchema(objName, meType.Schema)
								})

						return linq.From(result)
					},
				).
				ToMapByT(&componentsByName,
					func(kv linq.KeyValue) interface{} { return kv.Key },
					func(kv linq.KeyValue) interface{} { return kv.Value })

			return linq.From(componentsByName)
		}).
		GroupByT(
			func(kv linq.KeyValue) interface{} { return kv.Key },
			func(kv linq.KeyValue) interface{} { return kv.Value },
		).
		SelectT(func(kv linq.Group) jen.Code {
			var grouped []jen.Code
			linq.From(kv.Group).ToSlice(&grouped)
			return jen.Add(generator.normalizer.doubleLineAfterEachElement(grouped...)...)
		}).
		ToSlice(&componentsFromPathsResult)

	componentsResult = generator.normalizer.doubleLineAfterEachElement(componentsResult...)
	componentsFromPathsResult = generator.normalizer.doubleLineAfterEachElement(componentsFromPathsResult...)

	return jen.Null().
		Add(componentsResult...).
		Add(jen.Line()).
		Add(componentsFromPathsResult...).
		Add(jen.Line()).
		Add(generator.enums(swagger)).
		Add(jen.Line())
}

func (generator *Generator) variableForRegex(name string, schema *openapi3.SchemaRef) jen.Code {
	hasGoRegexExtension := len(schema.Value.Extensions) > 0 && schema.Value.Extensions[goRegex] != nil

	if !hasGoRegexExtension || schema.Value.Type != "string" {
		return jen.Null()
	}

	var regex string
	if err := json.Unmarshal(schema.Value.Extensions[goRegex].(json.RawMessage), &regex); err != nil {
		panic(err)
	}

	return jen.Var().
		Id(name).
		Op("=").
		Qual("regexp", "MustCompile").
		Call(jen.Lit(regex)).
		Line()
}

func (generator *Generator) additionalConstants(swagger *openapi3.Swagger) (jen.Code, []jen.Code) {
	var constantsComponentsCode []jen.Code

	linq.From(swagger.Components.Schemas).SelectManyT(func(kv linq.KeyValue) linq.Query {
		namePrefix := generator.normalizer.normalize(cast.ToString(kv.Key))
		namePrefix = generator.normalizer.decapitalize(cast.ToString(kv.Key))
		schema := kv.Value.(*openapi3.SchemaRef)

		return linq.From(schema.Value.Properties).SelectT(func(kv linq.KeyValue) jen.Code {
			name := namePrefix + generator.normalizer.normalize(strings.Title(cast.ToString(kv.Key))) + "Regex"
			return generator.variableForRegex(name, kv.Value.(*openapi3.SchemaRef))
		})
	}).ToSlice(&constantsComponentsCode)

	var componentsPathsCode []jen.Code

	linq.From(swagger.Paths).
		SelectManyT(func(kv linq.KeyValue) linq.Query {
			path := cast.ToString(kv.Key)

			return linq.From(kv.Value.(*openapi3.PathItem).Operations()).
				WhereT(func(kv linq.KeyValue) bool {
					operation := kv.Value.(*openapi3.Operation)
					return operation.RequestBody != nil && len(operation.RequestBody.Value.Content) > 0 &&
						linq.From(operation.RequestBody.Value.Content).
							AnyWithT(func(kv linq.KeyValue) bool { return kv.Value.(*openapi3.MediaType).Schema.Ref == "" })
				}).
				SelectManyT(func(kv linq.KeyValue) linq.Query {
					name := generator.normalizer.normalizeOperationName(path, cast.ToString(kv.Key))
					name = generator.normalizer.decapitalize(name)

					operation := kv.Value.(*openapi3.Operation)

					return linq.From(operation.RequestBody.Value.Content).
						SelectManyT(func(kv linq.KeyValue) linq.Query {
							meType := kv.Value.(*openapi3.MediaType)
							namePrefix := name + generator.normalizer.contentType(cast.ToString(kv.Key)+"Regex")

							var parametersConstants []jen.Code
							linq.From(meType.Schema.Value.Properties).SelectT(func(kv linq.KeyValue) jen.Code {
								name := namePrefix + generator.normalizer.normalize(strings.Title(cast.ToString(kv.Key))) + "Regex"
								return generator.variableForRegex(name, kv.Value.(*openapi3.SchemaRef))
							}).ToSlice(&parametersConstants)

							return linq.From(parametersConstants)
						})
				})
		}).ToSlice(&componentsPathsCode)

	componentsCode := jen.Null().
		Add(constantsComponentsCode...).
		Line().
		Add(componentsPathsCode...).
		Line()

	var parametersCode []jen.Code

	linq.From(swagger.Paths).
		SelectManyT(func(kv linq.KeyValue) linq.Query {
			path := cast.ToString(kv.Key)

			return linq.From(kv.Value.(*openapi3.PathItem).Operations()).
				SelectManyT(func(kv linq.KeyValue) linq.Query {
					name := generator.normalizer.normalizeOperationName(path, cast.ToString(kv.Key))
					name = generator.normalizer.decapitalize(name)

					operation := kv.Value.(*openapi3.Operation)
					return linq.From(operation.Parameters).SelectT(func(parameter *openapi3.ParameterRef) jen.Code {
						name := name + strings.Title(parameter.Value.In) + generator.normalizer.normalize(strings.Title(parameter.Value.Name)) + "Regex"
						return generator.variableForRegex(name, parameter.Value.Schema)
					})
				})
		}).ToSlice(&parametersCode)

	return componentsCode, parametersCode
}

func (generator *Generator) requestParameterStruct(name string, contentType string, appendContentTypeToName bool, operation *openapi3.Operation) jen.Code {
	type parameter struct {
		In   string
		Code jen.Code
	}

	var additionalParameters []parameter

	if contentType != "" {
		if appendContentTypeToName {
			name += generator.normalizer.contentType(contentType)
		}

		bodyTypeName := generator.normalizer.extractNameFromRef(operation.RequestBody.Value.Content[contentType].Schema.Ref)
		if bodyTypeName == "" {
			bodyTypeName = name + "RequestBody"
		}

		additionalParameters = append(additionalParameters,
			parameter{In: "Body", Code: jen.Id("Body").Qual(generator.config.ComponentsPackage, bodyTypeName)})
	}

	var parameterStructs []jen.Code

	linq.From(operation.Parameters).
		GroupByT(
			func(parameter *openapi3.ParameterRef) string { return parameter.Value.In },
			func(parameter *openapi3.ParameterRef) *openapi3.ParameterRef { return parameter }).
		SelectT(
			func(group linq.Group) jen.Code {
				var structFields []jen.Code
				linq.From(group.Group).
					OrderByT(func(parameter *openapi3.ParameterRef) string { return parameter.Value.Name }).
					SelectT(func(parameter *openapi3.ParameterRef) (result jen.Code) {
						name := generator.normalizer.normalize(parameter.Value.Name)
						var statement = jen.Id(name)

						if len(parameter.Value.Schema.Value.Enum) > 0 {
							if len(parameter.Value.Schema.Ref) > 0 {
								generator.typee.fillGoType(statement, generator.normalizer.extractNameFromRef(parameter.Value.Schema.Ref), parameter.Value.Schema, false, false)
								return statement
							}

							//todo: generate enum for anonymous type
						}

						generator.typee.fillGoType(statement, name, parameter.Value.Schema, false, false)
						return statement
					}).
					ToSlice(&structFields)

				var getters []jen.Code

				typeName := name + "Request" + strings.Title(cast.ToString(group.Key))

				linq.From(group.Group).
					OrderByT(func(parameter *openapi3.ParameterRef) string { return parameter.Value.Name }).
					SelectT(func(parameter *openapi3.ParameterRef) (result jen.Code) {
						name := generator.normalizer.normalize(parameter.Value.Name)
						var statement = jen.Func().Params(jen.Id(parameter.Value.In).Id(typeName)).Id("Get" + name).Params()

						if len(parameter.Value.Schema.Value.Enum) > 0 {
							if len(parameter.Value.Schema.Ref) > 0 {
								var returnType = jen.Null()
								generator.typee.fillGoType(returnType, generator.normalizer.extractNameFromRef(parameter.Value.Schema.Ref), parameter.Value.Schema, false, false)
								statement = statement.Params(returnType).Block(jen.Return().Id(parameter.Value.In).Dot(name))
								return statement
							}

							//todo: generate enum for anonymous type
						}

						var returnType = jen.Null()
						generator.typee.fillGoType(returnType, name, parameter.Value.Schema, false, false)
						statement = statement.Params(returnType).Block(jen.Return().Id(parameter.Value.In).Dot(name))
						return statement
					}).
					ToSlice(&getters)

				return jen.Type().Id(typeName).Struct(structFields...).
					Line().Line().
					Add(generator.normalizer.doubleLineAfterEachElement(getters...)...)
			}).
		ToSlice(&parameterStructs)

	var parameters []jen.Code

	linq.From(operation.Parameters).
		GroupByT(
			func(parameter *openapi3.ParameterRef) string { return parameter.Value.In },
			func(parameter *openapi3.ParameterRef) *openapi3.ParameterRef { return parameter }).
		SelectT(
			func(group linq.Group) (parameter parameter) {
				var structFields []jen.Code
				linq.From(group.Group).
					OrderByT(func(parameter *openapi3.ParameterRef) string { return parameter.Value.Name }).
					SelectT(func(parameter *openapi3.ParameterRef) (result jen.Code) {
						name := generator.normalizer.normalize(parameter.Value.Name)
						var statement = jen.Id(name)

						if len(parameter.Value.Schema.Value.Enum) > 0 {
							if len(parameter.Value.Schema.Ref) > 0 {
								generator.typee.fillGoType(statement, generator.normalizer.extractNameFromRef(parameter.Value.Schema.Ref), parameter.Value.Schema, false, false)
								return statement
							}

							//todo: generate enum for anonymous type
						}

						generator.typee.fillGoType(statement, name, parameter.Value.Schema, false, false)
						return statement
					}).
					ToSlice(&structFields)

				parameter.In = cast.ToString(group.Key)
				parameter.Code = jen.Id(strings.Title(cast.ToString(group.Key))).Id(name + "Request" + strings.Title(cast.ToString(group.Key)))

				return
			}).
		Concat(linq.From(additionalParameters)).
		OrderByT(func(parameter parameter) string { return parameter.In }).
		SelectT(func(parameter parameter) jen.Code { return parameter.Code }).
		ToSlice(&parameters)

	parameters = append(parameters, jen.Id("ProcessingResult").Id("RequestProcessingResult"))

	hasSecuritySchemas := operation.Security != nil && len(*operation.Security) > 0
	if hasSecuritySchemas {
		parameters = append(parameters, jen.Id("SecurityCheckResults").Map(jen.Id("SecurityScheme")).Id("string"))
	}

	return jen.Null().
		Add(generator.normalizer.doubleLineAfterEachElement(parameterStructs...)...).
		Line().Line().
		Add(jen.Type().Id(name + "Request").Struct(parameters...)).
		Line().Line()
}

func (generator *Generator) enumFromSchema(name string, schema *openapi3.SchemaRef) jen.Code {
	if len(schema.Ref) > 0 {
		return jen.Null()
	}

	var result []jen.Code
	var enumValues []jen.Code

	result = append(result, jen.Type().Id(generator.normalizer.normalize(name)).String())

	linq.From(schema.Value.Enum).SelectT(func(value string) jen.Code {
		return jen.Var().Id(name + generator.normalizer.normalize(strings.Title(value))).Id(name).Op("=").Lit(value)
	}).ToSlice(&enumValues)

	var enumSwitchCases []jen.Code

	linq.From(schema.Value.Enum).SelectT(func(value string) jen.Code {
		return jen.Id(name + generator.normalizer.normalize(strings.Title(value)))
	}).ToSlice(&enumSwitchCases)

	result = append(result, enumValues...)

	result = append(result, jen.Func().Params(
		jen.Id("enum").Id(name)).Id("Check").Params().Params(
		jen.Id("error")).Block(
		jen.Switch(jen.Id("enum")).Block(
			jen.Case(enumSwitchCases...).Block(
				jen.Line().Return().Id("nil"))),
		jen.Line().Return().Qual("fmt",
			"Errorf").Call(jen.Lit(fmt.Sprintf("invalid %s enum value", name))),
	).Add(jen.Line()))

	result = append(result, jen.Func().Params(
		jen.Id("enum").Op("*").Id(name)).Id("UnmarshalJSON").Params(
		jen.Id("data").Index().Id("byte")).Params(
		jen.Id("error")).Block(
		jen.Var().Id("strValue").Id("string"),
		jen.If(jen.Id("err").Op(":=").Qual("encoding/json",
			"Unmarshal").Call(jen.Id("data"),
			jen.Op("&").Id("strValue")),
			jen.Id("err").Op("!=").Id("nil")).Block(
			jen.Line().Return().Id("err")),
		jen.Id("enumValue").Op(":=").Id(name).Call(jen.Id("strValue")),
		jen.If(jen.Id("err").Op(":=").Id("enumValue").Dot("Check").Call(),
			jen.Id("err").Op("!=").Id("nil")).Block(
			jen.Line().Return().Id("err")),
		jen.Op("*").Id("enum").Op("=").Id("enumValue"),
		jen.Line().Return().Id("nil"),
	))

	result = generator.normalizer.lineAfterEachElement(result...)

	return jen.Null().Add(result...).Add(jen.Line())
}

func (generator *Generator) getXGoRegex(schema *openapi3.SchemaRef) string {
	if len(schema.Value.Extensions) > 0 && schema.Value.Extensions[goRegex] != nil {
		var regex string
		if err := json.Unmarshal(schema.Value.Extensions[goRegex].(json.RawMessage), &regex); err != nil {
			panic(err)
		}

		return regex
	}

	return ""
}

func (generator *Generator) componentFromSchema(name string, parentSchema *openapi3.SchemaRef) jen.Code {
	name = generator.normalizer.normalize(name)

	typeDeclaration := jen.Type().Id(name)

	if len(parentSchema.Value.Properties) == 0 {
		if len(parentSchema.Value.Enum) > 0 {
			generator.typee.fillGoType(typeDeclaration, name+"Enum", parentSchema, false, false)
			return typeDeclaration
		}

		generator.typee.fillGoType(typeDeclaration, name, parentSchema, false, true)

		return typeDeclaration
	}

	componentStruct := typeDeclaration.Struct(generator.typeProperties(name, parentSchema.Value, false)...)
	helperName := generator.normalizer.decapitalize(name)
	componentHelperStruct := jen.Type().Id(helperName).Struct(generator.typeProperties(helperName, parentSchema.Value, true)...)

	var unmarshalNonRequiredAssignments []jen.Code
	linq.From(parentSchema.Value.Properties).
		WhereT(func(kv linq.KeyValue) bool { return !linq.From(parentSchema.Value.Required).Contains(kv.Key) }).
		SelectT(func(kv linq.KeyValue) jen.Code {
			property := cast.ToString(kv.Key)
			propertyName := strings.Title(generator.normalizer.normalize(property))

			var additionalValidationCode []jen.Code
			schema := kv.Value.(*openapi3.SchemaRef)
			regex := generator.getXGoRegex(schema)
			if regex != "" {
				regexVarName := generator.normalizer.decapitalize(name) + strings.Title(property) + "Regex"
				additionalValidationCode = append(additionalValidationCode,
					jen.If(jen.Op("!").Id(regexVarName).Dot("MatchString").Call(jen.Id("body").Dot(propertyName))).Block(
						jen.Return().Qual("fmt",
							"Errorf").Call(jen.Lit(fmt.Sprintf(`%s not matched by the '%s' regex`, property, html.EscapeString(regex))))))
			}

			return jen.Null().
				Add(additionalValidationCode...).
				Id("body").Dot(propertyName).Op("=").Id("value").Dot(propertyName).Line()
		}).
		ToSlice(&unmarshalNonRequiredAssignments)

	var unmarshalRequiredAssignments []jen.Code
	linq.From(parentSchema.Value.Properties).
		WhereT(func(kv linq.KeyValue) bool {
			return linq.From(parentSchema.Value.Required).Contains(cast.ToString(kv.Key))
		}).
		SelectT(func(kv linq.KeyValue) jen.Code {
			property := cast.ToString(kv.Key)
			propertyName := strings.Title(generator.normalizer.normalize(property))

			var additionalValidationCode []jen.Code
			schema := kv.Value.(*openapi3.SchemaRef)
			regex := generator.getXGoRegex(schema)
			if regex != "" {
				regexVarName := generator.normalizer.decapitalize(name) + strings.Title(property) + "Regex"
				additionalValidationCode = append(additionalValidationCode,
					jen.If(jen.Op("!").Id(regexVarName).Dot("MatchString").Call(jen.Op("*").Id("value").Dot(propertyName))).Block(
						jen.Return().Qual("fmt",
							"Errorf").Call(jen.Lit(fmt.Sprintf(`%s not matched by the '%s' regex`, property, html.EscapeString(regex))))))
			}

			code := jen.If(jen.Id("value").Dot(propertyName).Op("==").Id("nil")).
				Block(jen.Return().Qual("fmt", "Errorf").Call(jen.Lit(fmt.Sprintf("%s is required", property)))).
				Line().Line().
				Add(additionalValidationCode...).
				Line().Line().
				Id("body").Dot(propertyName).Op("=").Op("*").Id("value").Dot(propertyName).
				Line().Line()

			return code
		}).ToSlice(&unmarshalRequiredAssignments)

	unmarshalFunc := jen.Func().Params(
		jen.Id("body").Op("*").Id(name)).Id("UnmarshalJSON").Params(
		jen.Id("data").Index().Id("byte")).Params(
		jen.Id("error")).Block(
		jen.Var().Id("value").Id(helperName),
		jen.If(jen.Id("err").Op(":=").Qual("encoding/json",
			"Unmarshal").Call(jen.Id("data"),
			jen.Op("&").Id("value")),
			jen.Id("err").Op("!=").Id("nil")).Block(
			jen.Return().Id("err")).Line().Line().
			Add(unmarshalNonRequiredAssignments...).Line().Line().
			Add(unmarshalRequiredAssignments...).Line().Line().
			Add(jen.Return().Id("nil")))

	return jen.Add(componentHelperStruct).
		Add(jen.Line().Line()).
		Add(componentStruct).
		Add(jen.Line().Line()).
		Add(unmarshalFunc)
}

func (generator *Generator) typeProperties(typeName string, schema *openapi3.Schema, pointersForRequired bool) (parameters []jen.Code) {
	linq.From(schema.Properties).
		OrderByT(func(kv linq.KeyValue) interface{} { return kv.Key }).
		SelectT(func(kv linq.KeyValue) interface{} {
			originName := cast.ToString(kv.Key)
			name := generator.normalizer.normalize(originName)
			parameter := jen.Id(name)
			schemaRef := kv.Value.(*openapi3.SchemaRef)
			if len(schemaRef.Value.Enum) > 0 {
				if schemaRef.Ref != "" {
					name = generator.normalizer.extractNameFromRef(schemaRef.Ref)
				} else {
					name = strings.Title(typeName) + strings.Title(name) + "Enum"
				}
			}

			asPointer := pointersForRequired && linq.From(schema.Required).Contains(originName)

			generator.typee.fillGoType(parameter, name, schemaRef, asPointer, false)
			generator.typee.fillJsonTag(parameter, originName)
			return parameter
		}).ToSlice(&parameters)

	return
}

func (generator *Generator) enums(swagger *openapi3.Swagger) jen.Code {
	var pathsResult []jen.Code

	linq.From(swagger.Paths).
		SelectManyT(func(kv linq.KeyValue) linq.Query {
			path := cast.ToString(kv.Key)

			return linq.From(kv.Value.(*openapi3.PathItem).Operations()).
				SelectManyT(func(kv linq.KeyValue) linq.Query {
					var requestBodyResults []jen.Code

					name := generator.normalizer.normalizeOperationName(path, cast.ToString(kv.Key))
					operation := kv.Value.(*openapi3.Operation)

					if operation.RequestBody != nil {
						linq.From(operation.RequestBody.Value.Content).
							SelectT(func(kv linq.KeyValue) jen.Code {
								schema := kv.Value.(*openapi3.MediaType).Schema

								namePrefix := generator.normalizer.normalize(name + generator.normalizer.contentType(cast.ToString(kv.Key)))

								if len(schema.Value.Enum) > 0 {
									return generator.enumFromSchema(namePrefix+"RequestBodyEnum", schema)
								}

								var result []jen.Code
								linq.From(schema.Value.Properties).WhereT(func(kv linq.KeyValue) bool {
									return len(kv.Value.(*openapi3.SchemaRef).Value.Enum) > 0
								}).SelectT(func(kv linq.KeyValue) interface{} {
									enumName := namePrefix + generator.normalizer.normalize(strings.Title(cast.ToString(kv.Key))) + "Enum"
									enumName = generator.normalizer.normalize(enumName)
									return generator.enumFromSchema(enumName, kv.Value.(*openapi3.SchemaRef))
								}).ToSlice(&result)

								return jen.Null().Add(generator.normalizer.doubleLineAfterEachElement(result...)...)
							}).ToSlice(&requestBodyResults)
					}

					var result []jen.Code
					linq.From(operation.Responses).
						SelectManyT(func(kv linq.KeyValue) linq.Query {
							return linq.From(kv.Value.(*openapi3.ResponseRef).Value.Content).
								SelectT(func(kv linq.KeyValue) jen.Code {
									schema := kv.Value.(*openapi3.MediaType).Schema
									namePrefix := generator.normalizer.normalize(name + generator.normalizer.contentType(cast.ToString(kv.Key)))

									if len(schema.Value.Enum) > 0 {
										return generator.enumFromSchema(namePrefix+"ResponseBodyEnum", schema)
									}

									var result []jen.Code
									linq.From(schema.Value.Properties).WhereT(func(kv linq.KeyValue) bool {
										return len(kv.Value.(*openapi3.SchemaRef).Value.Enum) > 0
									}).SelectT(func(kv linq.KeyValue) interface{} {
										enumName := namePrefix + generator.normalizer.normalize(strings.Title(cast.ToString(kv.Key))) + "Enum"
										enumName = generator.normalizer.normalize(enumName)
										return generator.enumFromSchema(enumName, kv.Value.(*openapi3.SchemaRef))
									}).ToSlice(&result)

									return jen.Null().Add(generator.normalizer.doubleLineAfterEachElement(result...)...)
								})
						}).
						Concat(linq.From(requestBodyResults)).
						ToSlice(&result)

					return linq.From(result)
				})
		}).ToSlice(&pathsResult)

	var componentsResult []jen.Code

	linq.From(swagger.Components.Schemas).
		SelectT(func(kv linq.KeyValue) jen.Code {
			namePrefix := generator.normalizer.normalize(cast.ToString(kv.Key))
			schema := kv.Value.(*openapi3.SchemaRef)

			if len(schema.Value.Enum) > 0 {
				return generator.enumFromSchema(namePrefix, schema)
			}

			var result []jen.Code
			linq.From(schema.Value.Properties).WhereT(func(kv linq.KeyValue) bool {
				return len(kv.Value.(*openapi3.SchemaRef).Value.Enum) > 0
			}).SelectT(func(kv linq.KeyValue) interface{} {
				enumName := namePrefix + generator.normalizer.normalize(strings.Title(cast.ToString(kv.Key))) + "Enum"
				enumName = generator.normalizer.normalize(enumName)
				return generator.enumFromSchema(enumName, kv.Value.(*openapi3.SchemaRef))
			}).ToSlice(&result)

			return jen.Null().Add(generator.normalizer.doubleLineAfterEachElement(result...)...)
		}).ToSlice(&componentsResult)

	return jen.Null().Add(generator.normalizer.lineAfterEachElement(pathsResult...)...).Add(generator.normalizer.lineAfterEachElement(componentsResult...)...)
}

func (generator *Generator) hooksStruct() jen.Code {
	return jen.Type().Id("Hooks").Struct(
		jen.Id("RequestSecurityParseFailed").Func().Params(jen.Op("*").Qual("net/http",
			"Request"),
			jen.Id("string"),
			jen.Id("RequestProcessingResult")),
		jen.Id("RequestSecurityParseCompleted").Func().Params(jen.Op("*").Qual("net/http",
			"Request"),
			jen.Id("string")),
		jen.Id("RequestSecurityCheckFailed").Func().Params(jen.Op("*").Qual("net/http",
			"Request"),
			jen.Id("string"),
			jen.Id("string"),
			jen.Id("RequestProcessingResult")),
		jen.Id("RequestSecurityCheckCompleted").Func().Params(jen.Op("*").Qual("net/http",
			"Request"),
			jen.Id("string"),
			jen.Id("string")),
		jen.Id("RequestBodyUnmarshalFailed").Func().Params(jen.Op("*").Qual("net/http",
			"Request"),
			jen.Id("string"),
			jen.Id("RequestProcessingResult")),
		jen.Id("RequestHeaderParseFailed").Func().Params(jen.Op("*").Qual("net/http",
			"Request"),
			jen.Id("string"),
			jen.Id("string"),
			jen.Id("RequestProcessingResult")),
		jen.Id("RequestPathParseFailed").Func().Params(jen.Op("*").Qual("net/http",
			"Request"),
			jen.Id("string"),
			jen.Id("string"),
			jen.Id("RequestProcessingResult")),
		jen.Id("RequestQueryParseFailed").Func().Params(jen.Op("*").Qual("net/http",
			"Request"),
			jen.Id("string"),
			jen.Id("string"),
			jen.Id("RequestProcessingResult")),
		jen.Id("RequestBodyUnmarshalCompleted").Func().Params(jen.Op("*").Qual("net/http",
			"Request"),
			jen.Id("string")),
		jen.Id("RequestHeaderParseCompleted").Func().Params(jen.Op("*").Qual("net/http",
			"Request"),
			jen.Id("string")),
		jen.Id("RequestPathParseCompleted").Func().Params(jen.Op("*").Qual("net/http",
			"Request"),
			jen.Id("string")),
		jen.Id("RequestQueryParseCompleted").Func().Params(jen.Op("*").Qual("net/http",
			"Request"),
			jen.Id("string")),
		jen.Id("RequestParseCompleted").Func().Params(jen.Op("*").Qual("net/http",
			"Request"),
			jen.Id("string")),
		jen.Id("RequestProcessingCompleted").Func().Params(jen.Op("*").Qual("net/http",
			"Request"),
			jen.Id("string")),
		jen.Id("RequestRedirectStarted").Func().Params(jen.Op("*").Qual("net/http",
			"Request"),
			jen.Id("string"), jen.Id("string")),
		jen.Id("ResponseBodyMarshalCompleted").Func().Params(jen.Op("*").Qual("net/http",
			"Request"),
			jen.Id("string")),
		jen.Id("ResponseBodyWriteCompleted").Func().Params(jen.Op("*").Qual("net/http",
			"Request"),
			jen.Id("string"), jen.Id("int")),
		jen.Id("ResponseBodyMarshalFailed").Func().Params(
			jen.Qual("net/http", "ResponseWriter"),
			jen.Op("*").Qual("net/http", "Request"),
			jen.Id("string"),
			jen.Id("error")),
		jen.Id("ResponseBodyWriteFailed").Func().Params(jen.Op("*").Qual("net/http",
			"Request"),
			jen.Id("string"),
			jen.Id("int"),
			jen.Id("error")),
		jen.Id("ServiceCompleted").Func().Params(jen.Op("*").Qual("net/http",
			"Request"),
			jen.Id("string")),
	)
}

func (generator *Generator) requestProcessingResultType() jen.Code {
	return jen.Type().Id("requestProcessingResultType").Id("uint8").
		Add(jen.Line(), jen.Line()).
		Add(jen.Const().Defs(
			jen.Id("BodyUnmarshalFailed").Id("requestProcessingResultType").Op("=").Id("iota").Op("+").Lit(1),
			jen.Id("HeaderParseFailed"),
			jen.Id("QueryParseFailed"),
			jen.Id("PathParseFailed"),
			jen.Id("SecurityParseFailed"),
			jen.Id("SecurityCheckFailed"),
			jen.Id("ParseSucceed"),
		)).
		Add(jen.Line(), jen.Line()).
		Add(jen.Type().Id("RequestProcessingResult").Struct(
			jen.Id("error").Id("error"),
			jen.Id("typee").Id("requestProcessingResultType"),
		)).
		Add(jen.Line(), jen.Line()).
		Add(jen.Func().Id("NewRequestProcessingResult").Params(
			jen.Id("t").Id("requestProcessingResultType"),
			jen.Id("err").Id("error")).
			Params(jen.Id("RequestProcessingResult")).Block(
			jen.Return().Id("RequestProcessingResult").Values(jen.Dict{
				jen.Id("typee"): jen.Id("t"),
				jen.Id("error"): jen.Id("err"),
			}))).
		Add(jen.Line(), jen.Line()).
		Add(jen.Func().Params(
			jen.Id("r").Id("RequestProcessingResult")).Id("Type").Params().Params(
			jen.Id("requestProcessingResultType")).Block(
			jen.Return().Id("r").Dot("typee"))).
		Add(jen.Line(), jen.Line()).
		Add(jen.Func().Params(
			jen.Id("r").Id("RequestProcessingResult")).Id("Err").Params().Params(
			jen.Id("error")).Block(
			jen.Return().Id("r").Dot("error"),
		))
}

func (generator *Generator) wrappers(swagger *openapi3.Swagger) jen.Code {
	var results []jen.Code

	linq.From(generator.groupedOperations(swagger)).
		SelectT(func(groupedOperations groupedOperations) jen.Code {
			tag := cast.ToString(groupedOperations.tag)

			var routes []jen.Code
			linq.From(groupedOperations.operations).
				SelectT(func(operation operationWithPath) jen.Code {
					method := generator.normalizer.normalize(strings.Title(strings.ToLower(cast.ToString(operation.method))))

					if operation.operation.RequestBody == nil || len(operation.operation.RequestBody.Value.Content) == 1 {
						name := generator.normalizer.normalizeOperationName(operation.path, cast.ToString(operation.method))
						return jen.Id("router").Dot("router").Dot(method).Call(jen.Lit(operation.path), jen.Id("router").Dot(name))
					}

					var result []jen.Code
					linq.From(operation.operation.RequestBody.Value.Content).
						SelectT(func(kv linq.KeyValue) jen.Code {
							name := generator.normalizer.normalizeOperationName(operation.path, cast.ToString(operation.method)) + generator.normalizer.contentType(cast.ToString(kv.Key))
							return jen.Id("router").Dot("router").Dot(method).Call(jen.Lit(operation.path), jen.Id("router").Dot(name))
						}).ToSlice(&result)

					return jen.Add(generator.normalizer.lineAfterEachElement(result...)...)
				}).ToSlice(&routes)

			var wrappers []jen.Code

			linq.From(groupedOperations.operations).
				SelectT(func(operation operationWithPath) jen.Code {
					method := generator.normalizer.normalize(strings.Title(strings.ToLower(cast.ToString(operation.method))))
					routerName := strings.ToLower(tag) + "Router"

					if operation.operation.RequestBody == nil {
						name := generator.normalizer.normalizeOperationName(operation.path, cast.ToString(operation.method))
						requestName := name + "Request"
						return generator.wrapper(name, requestName, routerName, method, operation.path, operation.operation, nil, "")
					}
					if len(operation.operation.RequestBody.Value.Content) == 1 {
						name := generator.normalizer.normalizeOperationName(operation.path, cast.ToString(operation.method))
						requestName := name + "Request"
						requestBody := linq.From(operation.operation.RequestBody.Value.Content).SelectT(func(kv linq.KeyValue) interface{} { return kv.Value }).First().(*openapi3.MediaType).Schema
						return generator.wrapper(name, requestName, routerName, method, operation.path, operation.operation, requestBody, "")
					}

					var result []jen.Code
					linq.From(operation.operation.RequestBody.Value.Content).
						SelectT(func(kv linq.KeyValue) interface{} {
							name := generator.normalizer.normalizeOperationName(operation.path, cast.ToString(operation.method)) + generator.normalizer.contentType(cast.ToString(kv.Key))
							requestName := name + "Request"
							requestBody := operation.operation.RequestBody.Value.Content[cast.ToString(kv.Key)].Schema
							return generator.wrapper(name, requestName, routerName, method, operation.path, operation.operation, requestBody, cast.ToString(kv.Key))
						}).
						ToSlice(&result)

					return jen.Add(generator.normalizer.lineAfterEachElement(result...)...)
				}).ToSlice(&wrappers)

			hasSecuritySchemas := linq.From(groupedOperations.operations).
				AnyWithT(func(operation operationWithPath) bool { return operation.operation.Security != nil && len(*operation.operation.Security) > 0 })

			return jen.Null().
				Add(generator.handler(strings.Title(tag)+"Handler", strings.Title(tag)+"Service", strings.ToLower(tag)+"Router", hasSecuritySchemas, groupedOperations.operations)).
				Add(jen.Line()).
				Add(generator.router(strings.ToLower(tag)+"Router", strings.Title(tag)+"Service", hasSecuritySchemas)).
				Add(jen.Line()).
				Add(jen.Func().Params(jen.Id("router").Op("*").Id(strings.ToLower(tag)+"Router")).Id("mount").Params().Block(routes...)).
				Add(jen.Line(), jen.Line()).
				Add(generator.normalizer.lineAfterEachElement(wrappers...)...).
				Add(jen.Line())

		}).ToSlice(&results)

	return jen.Null().
		Add(generator.hooksStruct()).
		Add(jen.Line(), jen.Line()).
		Add(generator.requestProcessingResultType()).
		Add(jen.Line(), jen.Line()).
		Add(generator.normalizer.lineAfterEachElement(results...)...).
		Add(jen.Line(), jen.Line())
}

type groupedOperations struct {
	tag        string
	operations []operationWithPath
}

type operationWithPath struct {
	method    string
	operation *openapi3.Operation
	path      string
}

func (generator *Generator) groupedOperations(swagger *openapi3.Swagger) []groupedOperations {
	var result []groupedOperations

	linq.From(swagger.Paths).
		SelectManyT(func(kv linq.KeyValue) linq.Query {
			path := cast.ToString(kv.Key)

			return linq.From(kv.Value.(*openapi3.PathItem).Operations()).
				SelectT(func(kv linq.KeyValue) groupedOperations {
					operation := kv.Value.(*openapi3.Operation)
					tag := operation.Tags[0]

					return groupedOperations{
						tag:        tag,
						operations: []operationWithPath{{operation: operation, path: path, method: cast.ToString(kv.Key)}},
					}
				})
		}).
		GroupByT(
			func(wrapper groupedOperations) string { return wrapper.tag },
			func(wrapper groupedOperations) groupedOperations { return wrapper }).
		SelectT(func(group linq.Group) groupedOperations {
			var operations []operationWithPath

			linq.From(group.Group).
				SelectT(func(wrapper groupedOperations) operationWithPath { return wrapper.operations[0] }).ToSlice(&operations)

			return groupedOperations{
				tag:        cast.ToString(group.Key),
				operations: operations,
			}
		}).
		ToSlice(&result)

	return result
}

func (generator *Generator) handler(name string, serviceName string, routerName string, hasSchemas bool, operations []operationWithPath) jen.Code {
	schemas := jen.Null()
	schemasInterfaceParameter := jen.Null()
	if hasSchemas {
		schemasInterfaceParameter = schemasInterfaceParameter.Id("securitySchemas").Id("SecuritySchemas")

		var declarations []jen.Code

		linq.From(operations).
			SelectManyT(func(operation operationWithPath) linq.Query {
				if operation.operation.Security == nil {
					return linq.From([]openapi3.SecurityRequirement{})
				}

				return linq.From(*operation.operation.Security)
			}).
			SelectManyT(func(securityRequirement openapi3.SecurityRequirement) linq.Query { return linq.From(securityRequirement).SelectT(func(kv linq.KeyValue) interface{} { return kv.Key }) }).
			Distinct().
			SelectT(func(name string) jen.Code {
				name = strings.Title(name)

				return jen.Line().Id("SecurityScheme"+name).Op(":").Values(jen.Line().Id("scheme").Op(":").Id("SecurityScheme"+name),
					jen.Line().Id("extract").Op(":").Id("securityExtractorsFuncs").Index(jen.Id("SecurityScheme"+name)),
					jen.Line().Id("handle").Op(":").Id("securitySchemas").Dot("SecurityScheme"+name),
					jen.Line(),
				)
			}).ToSlice(&declarations)

		declarations = append(declarations, jen.Line())

		schemas = schemas.Line().Id("router").Dot("securityHandlers").Op("=").Map(jen.Id("SecurityScheme")).Id("securityProcessor").
			Values(declarations...)
	}

	code := jen.Func().Id(name).
		Params(
			jen.Id("impl").Id(serviceName),
			jen.Id("r").Qual("github.com/go-chi/chi", "Router"),
			jen.Id("hooks").Op("*").Id("Hooks"), schemasInterfaceParameter).
		Params(jen.Qual("net/http", "Handler")).
		Block(
			jen.Id("router").Op(":=").Op("&").Id(routerName).Values(jen.Id("router").Op(":").Id("r"),
				jen.Id("service").Op(":").Id("impl"), jen.Id("hooks").Op(":").Id("hooks")),
			schemas,
			jen.Line().Id("router").Dot("mount").Call(),
			jen.Line().Return().Id("router").Dot("router"),
		)

	return code
}

func (generator *Generator) router(routerName string, serviceName string, hasSecuritySchemas bool) jen.Code {
	securityHandlers := jen.Null()
	if hasSecuritySchemas {
		securityHandlers = securityHandlers.Id("securityHandlers").Map(jen.Id("SecurityScheme")).Id("securityProcessor")
	}

	code := jen.Type().Id(routerName).Struct(
		jen.Id("router").Qual("github.com/go-chi/chi", "Router"),
		jen.Id("service").Id(serviceName),
		jen.Id("hooks").Op("*").Id("Hooks"),
		securityHandlers,
	)

	return code
}

func (generator *Generator) wrapperRequestParsers(wrapperName string, operation *openapi3.Operation) (result []jen.Code) {
	linq.From(operation.Parameters).
		GroupByT(
			func(parameter *openapi3.ParameterRef) string { return parameter.Value.In },
			func(parameter *openapi3.ParameterRef) *openapi3.ParameterRef { return parameter },
		).
		SelectManyT(func(group linq.Group) linq.Query {
			return linq.From(group.Group).SelectT(func(parameter *openapi3.ParameterRef) jen.Code {
				in := parameter.Value.In
				name := generator.normalizer.normalize(parameter.Value.Name)
				paramName := in + name
				if generator.typee.isCustomType(parameter.Value.Schema.Value) {
					return generator.wrapperCustomType(in, name, paramName, wrapperName, parameter)
				}

				if len(parameter.Value.Schema.Value.Enum) > 0 { //TODO: support anonymous enum types
					enumType := generator.normalizer.extractNameFromRef(parameter.Value.Schema.Ref)
					return generator.wrapperEnum(in, enumType, name, paramName, wrapperName, parameter)
				}

				if parameter.Value.Schema.Value.Type == "integer" {
					return generator.wrapperInteger(in, name, paramName, wrapperName, parameter)
				}

				return generator.wrapperStr(in, name, paramName, wrapperName, parameter)
			}).Concat(linq.From([]jen.Code{
				jen.Line().Add(jen.Line()).
					Add(jen.If(jen.Id("router").Dot("hooks").Dot("Request" + strings.Title(cast.ToString(group.Key)) + "ParseCompleted").Op("!=").Id("nil")).Block(
						jen.Id("router").Dot("hooks").Dot("Request"+strings.Title(cast.ToString(group.Key))+"ParseCompleted").Call(
							jen.Id("r"),
							jen.Lit(wrapperName)))),
			}))
		}).ToSlice(&result)

	return generator.normalizer.lineAfterEachElement(result...)
}

func (generator *Generator) wrapRequired(name string, isRequired bool, code jen.Code) jen.Code {
	if !isRequired {
		return jen.If(jen.Id(name).Op("!=").Lit("")).Block(code).Line()
	}

	return code
}

func (generator *Generator) wrapperCustomType(in string, name string, paramName string, wrapperName string, parameter *openapi3.ParameterRef) jen.Code {
	result := jen.Null()

	switch in {
	case "header":
		result = result.Add(jen.Id(paramName + "Str").Op(":=").Id("r").Dot("Header").Dot("Get").Call(jen.Lit(parameter.Value.Name)))
	case "query":
		result = result.Add(jen.Id(paramName + "Str").Op(":=").Id("r").Dot("URL").Dot("Query").Call().Dot("Get").Call(jen.Lit(parameter.Value.Name)))
	case "path":
		result = result.Add(jen.Id(paramName+"Str").Op(":=").Id("chi").Dot("URLParam").Call(jen.Id("r"), jen.Lit(parameter.Value.Name)))
	default:
		panic("unsupported " + in + " type")
	}

	result = result.Add(jen.Line())

	parseFailed := []jen.Code{
		jen.Id("request").Dot("ProcessingResult").Op("=").Id("RequestProcessingResult").Values(jen.Id("error").Op(":").Id("err"),
			jen.Id("typee").Op(":").Id(strings.Title(in)+"ParseFailed")),
		jen.If(jen.Id("router").Dot("hooks").Dot("Request" + strings.Title(in) + "ParseFailed").Op("!=").Id("nil")).Block(
			jen.Id("router").Dot("hooks").Dot("Request"+strings.Title(in)+"ParseFailed").Call(
				jen.Id("r"),
				jen.Lit(wrapperName),
				jen.Lit(parameter.Value.Name),
				jen.Id("request").Dot("ProcessingResult"))),
		jen.Line().Return(),
	}

	if pkg, parse, ok := generator.typee.getXGoTypeStringParse(parameter.Value.Schema.Value); ok {
		parameterCode := jen.Null().
			Add(jen.List(jen.Id(paramName), jen.Id("err")).Op(":=").Qual(pkg, parse).Call(jen.Id(paramName+"Str"))).
			Add(jen.Line()).
			Add(jen.If(jen.Id("err").Op("!=").Id("nil")).Block(parseFailed...)).
			Add(jen.Line(), jen.Line()).
			Add(jen.Id("request").Dot(strings.Title(in)).Dot(name).Op("=").Id(paramName))

		result.Add(generator.wrapRequired(paramName+"Str", parameter.Value.Required, parameterCode))
	} else {
		switch parameter.Value.Schema.Value.Format {
		case "uuid":
			parameterCode := jen.Null().
				Add(jen.List(jen.Id(paramName), jen.Id("err")).Op(":=").Id("uuid").Dot("Parse").Call(jen.Id(paramName+"Str"))).
				Add(jen.Line()).
				Add(jen.If(jen.Id("err").Op("!=").Id("nil")).Block(parseFailed...)).
				Add(jen.Line(), jen.Line()).
				Add(jen.Id("request").Dot(strings.Title(in)).Dot(name).Op("=").Id(paramName))

			result.Add(generator.wrapRequired(paramName+"Str", parameter.Value.Required, parameterCode))
			break
		case "iso4217-currency-code":
			parameterCode := jen.Null().
				Add(jen.List(jen.Id(paramName), jen.Id("err")).Op(":=").Qual("github.com/mikekonan/go-currencies", "ByCodeStrErr").Call(jen.Id(paramName+"Str"))).
				Add(jen.Line()).
				Add(jen.If(jen.Id("err").Op("!=").Id("nil")).Block(parseFailed...)).
				Add(jen.Line(), jen.Line()).
				Add(jen.Id("request").Dot(strings.Title(in)).Dot(name).Op("=").Id(paramName).Dot("Code").Call())

			result.Add(generator.wrapRequired(paramName+"Str", parameter.Value.Required, parameterCode))
			break
		case "iso3166-alpha-2":
			parameterCode := jen.Null().
				Add(jen.List(jen.Id(paramName), jen.Id("err")).Op(":=").Qual("github.com/mikekonan/go-countries", "ByAlpha2CodeStrErr").Call(jen.Id(paramName+"Str"))).
				Add(jen.Line()).
				Add(jen.If(jen.Id("err").Op("!=").Id("nil")).Block(parseFailed...)).
				Add(jen.Line(), jen.Line()).
				Add(jen.Id("request").Dot(strings.Title(in)).Dot(name).Op("=").Id(paramName).Dot("Alpha2Code").Call())

			result.Add(generator.wrapRequired(paramName+"Str", parameter.Value.Required, parameterCode))
			break
		default:
		}
	}

	return result.Line()
}

func (generator *Generator) wrapperEnum(in string, enumType string, name string, paramName string, wrapperName string, parameter *openapi3.ParameterRef) jen.Code {
	result := jen.Null()

	switch in {
	case "header":
		result = result.Add(jen.Id(paramName).Op(":=").Qual(generator.config.ComponentsPackage, enumType).Call(jen.Id("r").Dot("Header").Dot("Get").Call(jen.Lit(parameter.Value.Name))))
	case "query":
		result = result.Add(jen.Id(paramName).Op(":=").Qual(generator.config.ComponentsPackage, enumType).Call(jen.Id("r").Dot("URL").Dot("Query").Call().Dot("Get").Call(jen.Lit(parameter.Value.Name))))
	case "path":
		result = result.Add(jen.Id(paramName).Op(":=").Qual(generator.config.ComponentsPackage, enumType).Call(jen.Id("chi").Dot("URLParam").Call(jen.Id("r"), jen.Lit(parameter.Value.Name))))
	default:
		panic("unsupported " + in + " type")
	}

	result = result.
		Add(jen.Line()).
		Add(jen.If(jen.Id("err").Op(":=").Id(paramName).Dot("Check").Call(),
			jen.Id("err").Op("!=").Id("nil")).Block(
			jen.Id("request").Dot("ProcessingResult").Op("=").Id("RequestProcessingResult").Values(jen.Id("error").Op(":").Id("err"),
				jen.Id("typee").Op(":").Id(strings.Title(in)+"ParseFailed")),
			jen.If(jen.Id("router").Dot("hooks").Dot("Request"+strings.Title(in)+"ParseFailed").Op("!=").Id("nil")).Block(
				jen.Id("router").Dot("hooks").Dot("Request"+strings.Title(in)+"ParseFailed").Call(
					jen.Id("r"),
					jen.Lit(wrapperName),
					jen.Lit(parameter.Value.Name),
					jen.Id("request").Dot("ProcessingResult"))),
			jen.Line().Return())).
		Add(jen.Line(), jen.Line()).
		Add(jen.Id("request").Dot(strings.Title(parameter.Value.In)).Dot(name).Op("=").Id(paramName)).
		Add(jen.Line())

	return jen.Null().Add(generator.wrapRequired(paramName, parameter.Value.Required, result)).Line()
}

func (generator *Generator) wrapperStr(in string, name string, paramName string, wrapperName string, parameter *openapi3.ParameterRef) jen.Code {
	result := jen.Null()

	switch in {
	case "header":
		result = result.Add(jen.Id(paramName).Op(":=").Id("r").Dot("Header").Dot("Get").Call(jen.Lit(parameter.Value.Name)))
	case "query":
		result = result.Add(jen.Id(paramName).Op(":=").Id("r").Dot("URL").Dot("Query").Call().Dot("Get").Call(jen.Lit(parameter.Value.Name)))
	case "path":
		result = result.Add(jen.Id(paramName).Op(":=").Id("chi").Dot("URLParam").Call(jen.Id("r"), jen.Lit(parameter.Value.Name)))
	default:
		panic("unsupported " + in + " type")
	}

	if parameter.Value.Required {
		result = result.
			Add(jen.Line()).
			Add(jen.If(jen.Id(paramName).Op("==").Lit("")).Block(
				jen.Id("err").Op(":=").Qual("fmt", "Errorf").Call(jen.Lit(fmt.Sprintf("%s is empty", parameter.Value.Name))).Line(),
				jen.Id("request").Dot("ProcessingResult").Op("=").Id("RequestProcessingResult").Values(jen.Id("error").Op(":").Id("err"),
					jen.Id("typee").Op(":").Id(strings.Title(in)+"ParseFailed")),
				jen.If(jen.Id("router").Dot("hooks").Dot("Request"+strings.Title(in)+"ParseFailed").Op("!=").Id("nil")).Block(
					jen.Id("router").Dot("hooks").Dot("Request"+strings.Title(in)+"ParseFailed").Call(
						jen.Id("r"),
						jen.Lit(wrapperName),
						jen.Lit(parameter.Value.Name),
						jen.Id("request").Dot("ProcessingResult"))),
				jen.Line().Return())).
			Add(jen.Line())
	}

	regex := generator.getXGoRegex(parameter.Value.Schema)
	if regex != "" {
		regexVarName := generator.normalizer.decapitalize(wrapperName) + strings.Title(in) + name + "Regex"

		result = result.Line().If(jen.Op("!").Id(regexVarName).Dot("MatchString").Call(jen.Id("request").Dot("Header").Dot(name))).Block(
			jen.Id("err").Op(":=").Qual("fmt",
				"Errorf").Call(jen.Lit(fmt.Sprintf("%s not matched by the '%s' regex", parameter.Value.Name, regex))),
			jen.Line(),
			jen.Id("request").Dot("ProcessingResult").Op("=").Id("RequestProcessingResult").Values(jen.Id("error").Op(":").Id("err"),
				jen.Id("typee").Op(":").Id(fmt.Sprintf("%sParseFailed", strings.Title(in)))),
			jen.If(jen.Id("router").Dot("hooks").Dot("Request"+strings.Title(in)+"ParseFailed").Op("!=").Id("nil")).Block(
				jen.Id("router").Dot("hooks").Dot("Request"+strings.Title(in)+"ParseFailed").Call(jen.Id("r"),
					jen.Lit(wrapperName),
					jen.Lit(parameter.Value.Name),
					jen.Id("request").Dot("ProcessingResult"))),
			jen.Line(),
			jen.Return()).
			Line()
	}

	result = result.
		Line().
		Add(jen.Id("request").Dot(strings.Title(parameter.Value.In)).Dot(name).Op("=").Id(paramName)).
		Line()

	return result
}

func (generator *Generator) wrapperInteger(in string, name string, paramName string, wrapperName string, parameter *openapi3.ParameterRef) jen.Code {
	result := jen.Null()

	switch in {
	case "header":
		result = result.Add(jen.Id(paramName).Op(":=").Id("r").Dot("Header").Dot("Get").Call(jen.Lit(parameter.Value.Name)))
	case "query":
		result = result.Add(jen.Id(paramName).Op(":=").Id("r").Dot("URL").Dot("Query").Call().Dot("Get").Call(jen.Lit(parameter.Value.Name)))
	case "path":
		result = result.Add(jen.Id(paramName).Op(":=").Id("chi").Dot("URLParam").Call(jen.Id("r"), jen.Lit(parameter.Value.Name)))
	default:
		panic("unsupported " + in + " type")
	}

	if parameter.Value.Required {
		result = result.
			Add(jen.Line()).
			Add(jen.If(jen.Id(paramName).Op("==").Lit("")).Block(
				jen.Id("err").Op(":=").Qual("fmt", "Errorf").Call(jen.Lit(fmt.Sprintf("%s is empty", parameter.Value.Name))).Line(),
				jen.Id("request").Dot("ProcessingResult").Op("=").Id("RequestProcessingResult").Values(jen.Id("error").Op(":").Id("err"),
					jen.Id("typee").Op(":").Id(strings.Title(in)+"ParseFailed")),
				jen.If(jen.Id("router").Dot("hooks").Dot("Request"+strings.Title(in)+"ParseFailed").Op("!=").Id("nil")).Block(
					jen.Id("router").Dot("hooks").Dot("Request"+strings.Title(in)+"ParseFailed").Call(
						jen.Id("r"),
						jen.Lit(wrapperName),
						jen.Lit(parameter.Value.Name),
						jen.Id("request").Dot("ProcessingResult"))),
				jen.Line().Return())).
			Add(jen.Line())
	}

	return result.
		Add(jen.Line()).
		Add(jen.Id("request").Dot(strings.Title(parameter.Value.In)).Dot(name).Op("=").Qual("github.com/spf13/cast", "ToInt").Call(jen.Id(paramName))).
		Add(jen.Line())
}

func (generator *Generator) wrapperBody(method string, path string, contentType string, wrapperName string, operation *openapi3.Operation, body *openapi3.SchemaRef) jen.Code {
	result := jen.Null()

	if operation.RequestBody == nil {
		return result
	}

	name := generator.normalizer.extractNameFromRef(body.Ref)

	if name == "" {
		name = generator.normalizer.normalizeOperationName(path, method) + generator.normalizer.contentType(cast.ToString(contentType)) + "RequestBody"
	}

	return result.
		Add(jen.Var().Id("body").Qual(generator.config.ComponentsPackage, name)).
		Add(jen.Line()).
		Add(jen.If(jen.Id("err").Op(":=").Qual("encoding/json",
			"NewDecoder").Call(jen.Id("r").Dot("Body")).Dot("Decode").Call(jen.Op("&").Id("body")),
			jen.Id("err").Op("!=").Id("nil")).Block(
			jen.Id("request").Dot("ProcessingResult").Op("=").Id("RequestProcessingResult").Values(jen.Id("error").Op(":").Id("err"),
				jen.Id("typee").Op(":").Id("BodyUnmarshalFailed")),
			jen.If(jen.Id("router").Dot("hooks").Dot("RequestBodyUnmarshalFailed").Op("!=").Id("nil")).Block(
				jen.Id("router").Dot("hooks").Dot("RequestBodyUnmarshalFailed").Call(
					jen.Id("r"),
					jen.Lit(wrapperName),
					jen.Id("request").Dot("ProcessingResult")),
				jen.Line().Return()),
			jen.Line().Return())).
		Add(jen.Line(), jen.Line()).
		Add(jen.Id("request").Dot("Body").Op("=").Id("body")).
		Add(jen.Line(), jen.Line()).
		Add(jen.If(jen.Id("router").Dot("hooks").Dot("RequestBodyUnmarshalCompleted").Op("!=").Id("nil")).Block(
			jen.Id("router").Dot("hooks").Dot("RequestBodyUnmarshalCompleted").Call(
				jen.Id("r"),
				jen.Lit(wrapperName)))).
		Add(jen.Line())
}
func (generator *Generator) wrapperSecurity(name string, operation *openapi3.Operation) jen.Code {
	code := jen.Null()

	hasSecuritySchemas := operation.Security != nil && len(*operation.Security) > 0
	if !hasSecuritySchemas {
		return code
	}

	var schemasCode []jen.Code
	linq.From(*operation.Security).
		SelectT(func(securityRequirement openapi3.SecurityRequirement) jen.Code {
			var handlers []jen.Code
			linq.From(securityRequirement).SelectT(func(kv linq.KeyValue) jen.Code {
				return jen.Id("router").Dot("securityHandlers").Index(jen.Id("SecurityScheme" + strings.Title(cast.ToString(kv.Key))))
			}).ToSlice(&handlers)

			return jen.Values(handlers...)
		}).
		ToSlice(&schemasCode)

	code = code.Line().Id("isSecurityCheckPassed").Op(":=").Id("false").Line().
		For(jen.List(jen.Id("_"),
			jen.Id("processors")).Op(":=").Range().Index().Index().Id("securityProcessor").Values(schemasCode...)).Block(
		jen.Id("isLinkedChecksValid").Op(":=").Id("true"),
		jen.Line().For(jen.List(jen.Id("_"),
			jen.Id("processor")).Op(":=").Range().Id("processors")).Block(
			jen.List(jen.Id("value"),
				jen.Id("isExtracted")).Op(":=").Id("processor").Dot("extract").Call(jen.Id("r")),
			jen.Line().If(jen.Op("!").Id("isExtracted")).Block(
				jen.Id("isLinkedChecksValid").Op("=").Id("false"),
				jen.Break()),
			jen.Line().If(jen.Id("err").Op(":=").Id("processor").Dot("handle").Call(jen.Id("r"),
				jen.Id("processor").Dot("scheme"),
				jen.Id("value")),
				jen.Id("err").Op("!=").Id("nil")).Block(
				jen.If(jen.Id("router").Dot("hooks").Dot("RequestSecurityCheckFailed").Op("!=").Id("nil")).Block(
					jen.Id("router").Dot("hooks").Dot("RequestSecurityCheckFailed").Call(jen.Id("r"),
						jen.Lit(name),
						jen.Id("string").Call(jen.Id("processor").Dot("scheme")),
						jen.Id("RequestProcessingResult").Values(jen.Id("error").Op(":").Id("err"), jen.Id("typee").Op(":").Id("SecurityCheckFailed")))),
				jen.Line().Id("isLinkedChecksValid").Op("=").Id("false"),
				jen.Line().Break()),
			jen.Line().If(jen.Id("router").Dot("hooks").Dot("RequestSecurityCheckCompleted").Op("!=").Id("nil")).Block(
				jen.Id("router").Dot("hooks").Dot("RequestSecurityCheckCompleted").Call(jen.Id("r"),
					jen.Lit(name),
					jen.Id("string").Call(jen.Id("processor").Dot("scheme")))),
			jen.Line().If(jen.Id("len").Call(jen.Id("request").Dot("SecurityCheckResults")).Op("==").Lit(0)).Block(
				jen.Id("request").Dot("SecurityCheckResults").Op("=").Map(jen.Id("SecurityScheme")).Id("string").Values()),
			jen.Line().Id("request").Dot("SecurityCheckResults").Index(jen.Id("processor").Dot("scheme")).Op("=").Id("value")),
		jen.Line().If(jen.Id("isLinkedChecksValid")).Block(
			jen.Id("isSecurityCheckPassed").Op("=").Id("true"),
			jen.Break())).
		Line().Line().If(jen.Op("!").Id("isSecurityCheckPassed")).Block(
		jen.Id("err").Op(":=").Qual("fmt",
			"Errorf").Call(jen.Lit("failed passing security checks")),
		jen.Line().Id("request").Dot("ProcessingResult").Op("=").Id("RequestProcessingResult").Values(jen.Id("error").Op(":").Id("err"),
			jen.Id("typee").Op(":").Id("SecurityParseFailed")),
		jen.Line().If(jen.Id("router").Dot("hooks").Dot("RequestSecurityParseFailed").Op("!=").Id("nil")).Block(
			jen.Id("router").Dot("hooks").Dot("RequestSecurityParseFailed").Call(jen.Id("r"),
				jen.Lit(name),
				jen.Id("request").Dot("ProcessingResult"))),
		jen.Line().Return()).Line()

	code = code.Line().If(jen.Id("router").Dot("hooks").Dot("RequestSecurityParseCompleted").Op("!=").Id("nil")).Block(
		jen.Id("router").Dot("hooks").Dot("RequestSecurityParseCompleted").Call(jen.Id("r"), jen.Lit(name)))

	return code.Line()
}
func (generator *Generator) wrapperRequestParser(name string, requestName string, routerName, method string, path string, operation *openapi3.Operation, requestBody *openapi3.SchemaRef, contentType string) jen.Code {
	funcCode := []jen.Code{
		jen.Id("request").Dot("ProcessingResult").Op("=").Id("RequestProcessingResult").Values(jen.Id("typee").Op(":").Id("ParseSucceed")).Line(),
	}

	funcCode = append(funcCode, generator.wrapperSecurity(name, operation))
	funcCode = append(funcCode, generator.wrapperRequestParsers(name, operation)...)
	funcCode = append(funcCode, generator.wrapperBody(method, path, contentType, name, operation, requestBody)) //TODO: support different content-types
	funcCode = append(funcCode, jen.Line().If(jen.Id("router").Dot("hooks").Dot("RequestParseCompleted").Op("!=").Id("nil")).Block(
		jen.Id("router").Dot("hooks").Dot("RequestParseCompleted").Call(
			jen.Id("r"),
			jen.Lit(name))))
	funcCode = append(funcCode, jen.Line().Return())

	return jen.Func().Params(
		jen.Id("router").Op("*").Id(routerName)).Id("parse" + name + "Request").
		Params(jen.Id("r").Op("*").Qual("net/http", "Request")).
		Params(jen.Id("request").Id(requestName)).
		Block(funcCode...).
		Line()
}

func (generator *Generator) wrapper(name string, requestName string, routerName, method string, path string, operation *openapi3.Operation, requestBody *openapi3.SchemaRef, contentType string) jen.Code {
	var funcCode []jen.Code

	funcCode = append(funcCode, jen.Id("response").Op(":=").Id("router").Dot("service").Dot(name).Call(jen.Id("r").Dot("Context").Call(),
		jen.Id("router").Dot("parse"+name+"Request").Call(jen.Id("r"))),
		jen.Line().Line(),
		jen.If(jen.Id("response").Dot("statusCode").Call().Op("==").Lit(302).Op("&&").Id("response").Dot("redirectURL").Call().Op("!=").Lit("")).Block(
			jen.If(jen.Id("router").Dot("hooks").Dot("RequestRedirectStarted").Op("!=").Id("nil")).Block(
				jen.Id("router").Dot("hooks").Dot("RequestRedirectStarted").Call(jen.Id("r"),
					jen.Lit(name), jen.Id("response").Dot("redirectURL").Call())),
			jen.Line().Line(),
			jen.Qual("net/http",
				"Redirect").Call(jen.Id("w"),
				jen.Id("r"),
				jen.Id("response").Dot("redirectURL").Call(),
				jen.Lit(302)),
			jen.Line().Line(),
			jen.If(jen.Id("router").Dot("hooks").Dot("ServiceCompleted").Op("!=").Id("nil")).
				Block(jen.Id("router").Dot("hooks").Dot("ServiceCompleted").Call(jen.Id("r"), jen.Lit(name))),
			jen.Line().Line(),
			jen.Return(),
		),
		jen.Line().Line(),
		jen.For(jen.List(jen.Id("header"),
			jen.Id("value")).Op(":=").Range().Id("response").Dot("headers").Call()).Block(
			jen.Id("w").Dot("Header").Call().Dot("Set").Call(jen.Id("header"),
				jen.Id("value"))))

	funcCode = append(funcCode, jen.Line().Add(jen.Line()).
		Add(jen.If(jen.Id("router").Dot("hooks").Dot("RequestProcessingCompleted").Op("!=").Id("nil")).Block(
			jen.Id("router").Dot("hooks").Dot("RequestProcessingCompleted").Call(
				jen.Id("r"),
				jen.Lit(name)))).Line().Line())

	if len(operation.Responses) > 0 && linq.From(operation.Responses).AnyWithT(func(kv linq.KeyValue) bool { return len(kv.Value.(*openapi3.ResponseRef).Value.Content) > 0 }) {
		funcCode = append(funcCode, jen.If(jen.Id("len").Call(jen.Id("response").Dot("contentType").Call()).Op(">").Lit(0)).Block(
			jen.Id("w").Dot("Header").Call().Dot("Set").Call(jen.Lit("content-type"),
				jen.Id("response").Dot("contentType").Call())).Line())

		funcCode = append(funcCode, jen.Id("w").Dot("WriteHeader").Call(jen.Id("response").Dot("statusCode").Call()).Line().Line())

		funcCode = append(funcCode, jen.If(jen.Id("response").Dot("body").Call().Op("!=").Id("nil")).Block(
			jen.Var().Defs(
				jen.Id("data").Index().Byte(),
				jen.Id("err").Error(),
			).Line(),
			jen.Switch(jen.Id("response").Dot("contentType").Call()).Block(
				jen.Case(jen.Lit("application/xml")).Block(
					jen.List(jen.Id("data"), jen.Id("err")).Op("=").
						Qual("encoding/xml", "Marshal").Call(jen.Id("response").Dot("body").Call()),
				),
				jen.Case(jen.Lit("text/html")).Block(
					jen.Id("data").Op("=").
						Index().Byte().Parens(jen.Qual("fmt", "Sprint").Call(jen.Id("response").Dot("body").Call())),
				),
				jen.Case(jen.Lit("application/json")).Block(
					jen.Fallthrough(),
				),
				jen.Default().Block(
					jen.List(jen.Id("data"), jen.Id("err")).Op("=").
						Qual("encoding/json", "Marshal").Call(jen.Id("response").Dot("body").Call()),
				),
			).Line(),
			jen.If(jen.Id("err").Op("!=").Id("nil")).Block(
				jen.If(jen.Id("router").Dot("hooks").Dot("ResponseBodyMarshalFailed").Op("!=").Id("nil")).Block(
					jen.Id("router").Dot("hooks").Dot("ResponseBodyMarshalFailed").Call(
						jen.Id("w"),
						jen.Id("r"),
						jen.Lit(name),
						jen.Id("err"))),
				jen.Line().Return()).Line().Line(),
			jen.If(jen.Id("router").Dot("hooks").Dot("ResponseBodyMarshalCompleted").Op("!=").Id("nil")).Block(
				jen.Id("router").Dot("hooks").Dot("ResponseBodyMarshalCompleted").Call(
					jen.Id("r"),
					jen.Lit(name))).Line().Line(),
			jen.List(jen.Id("count"),
				jen.Id("err")).Op(":=").Id("w").Dot("Write").Call(jen.Id("data")),
			jen.If(jen.Id("err").Op("!=").Id("nil")).Block(
				jen.If(jen.Id("router").Dot("hooks").Dot("ResponseBodyWriteFailed").Op("!=").Id("nil")).Block(
					jen.Id("router").Dot("hooks").Dot("ResponseBodyWriteFailed").Call(jen.Id("r"),
						jen.Lit(name),
						jen.Id("count"),
						jen.Id("err"))),
				jen.Line(),
				jen.If(jen.Id("router").Dot("hooks").Dot("ResponseBodyWriteCompleted").Op("!=").Id("nil")).Block(
					jen.Id("router").Dot("hooks").Dot("ResponseBodyWriteCompleted").Call(
						jen.Id("r"),
						jen.Lit(name), jen.Id("count"))),
				jen.Line().Return()).Line().Line(),
			jen.If(jen.Id("router").Dot("hooks").Dot("ResponseBodyWriteCompleted").Op("!=").Id("nil")).Block(
				jen.Id("router").Dot("hooks").Dot("ResponseBodyWriteCompleted").Call(
					jen.Id("r"),
					jen.Lit(name), jen.Id("count")))).Line().Line(),
		)
	} else {
		funcCode = append(funcCode, jen.Id("w").Dot("WriteHeader").Call(jen.Id("response").Dot("statusCode").Call()).Line().Line())
	}

	funcCode = append(funcCode, jen.If(jen.Id("router").Dot("hooks").Dot("ServiceCompleted").Op("!=").Id("nil")).
		Block(jen.Id("router").Dot("hooks").Dot("ServiceCompleted").Call(jen.Id("r"), jen.Lit(name))))

	return jen.Null().
		Add(generator.wrapperRequestParser(name, requestName, routerName, method, path, operation, requestBody, contentType)).
		Add(jen.Line()).
		Add(jen.Func().Params(
			jen.Id("router").Op("*").Id(routerName)).Id(name).Params(
			jen.Id("w").Qual("net/http", "ResponseWriter"),
			jen.Id("r").Op("*").Qual("net/http", "Request")).
			Block(funcCode...)).Line().Line()
}

func (generator *Generator) requestResponseBuilders(swagger *openapi3.Swagger) jen.Code {
	result := []jen.Code{
		generator.responseStruct(),
		generator.handlersTypes(swagger),
		generator.builders(swagger),
		generator.handlersInterfaces(swagger),
		generator.requestParameters(swagger.Paths),
	}

	result = generator.normalizer.doubleLineAfterEachElement(result...)

	return jen.Null().Add(result...)
}

type operationResponse struct {
	ContentTypeBodyNameMap map[string]string
	Headers                map[string]*openapi3.HeaderRef
	StatusCode             string
}

type operationStruct struct {
	Tag                   string
	Name                  string
	RequestName           string
	ResponseName          string
	Responses             []operationResponse
	InterfaceResponseName string
	PrivateName           string
}

func (generator *Generator) builders(swagger *openapi3.Swagger) (result jen.Code) {
	var builders []jen.Code

	linq.From(swagger.Paths).
		SelectManyT(func(kv linq.KeyValue) linq.Query {
			path := cast.ToString(kv.Key)
			var operationStructs []operationStruct

			linq.From(kv.Value.(*openapi3.PathItem).Operations()).
				SelectT(func(kv linq.KeyValue) operationStruct {
					name := generator.normalizer.normalizeOperationName(path, cast.ToString(kv.Key))
					operation := kv.Value.(*openapi3.Operation)
					var operationResponses []operationResponse

					linq.From(operation.Responses).
						SelectT(func(kv linq.KeyValue) (response operationResponse) {
							response.ContentTypeBodyNameMap = map[string]string{}
							response.Headers = kv.Value.(*openapi3.ResponseRef).Value.Headers

							linq.From(kv.Value.(*openapi3.ResponseRef).Value.Content).
								ToMapByT(&response.ContentTypeBodyNameMap,
									func(kv linq.KeyValue) string { return cast.ToString(kv.Key) },
									func(kv linq.KeyValue) (structName string) {
										if "" == kv.Value.(*openapi3.MediaType).Schema.Ref {
											structName = name
											structName += strings.Title(generator.normalizer.normalize(cast.ToString(kv.Key)))
											return structName
										}

										structName = generator.normalizer.extractNameFromRef(kv.Value.(*openapi3.MediaType).Schema.Ref)
										return
									})

							response.StatusCode = cast.ToString(kv.Key)

							return
						}).ToSlice(&operationResponses)

					return operationStruct{
						Tag:                   operation.Tags[0],
						Name:                  name,
						PrivateName:           generator.normalizer.decapitalize(name),
						RequestName:           name + "Request",
						InterfaceResponseName: name + "Response",
						ResponseName:          generator.normalizer.decapitalize(name + "Response"),
						Responses:             operationResponses,
					}
				}).ToSlice(&operationStructs)

			return linq.From(operationStructs)
		}).
		SelectT(func(operationStruct operationStruct) jen.Code { return generator.responseBuilders(operationStruct) }).
		ToSlice(&builders)

	return jen.Null().Add(builders...)
}

func (generator *Generator) handlersTypes(swagger *openapi3.Swagger) jen.Code {
	var result []jen.Code

	linq.From(swagger.Paths).
		SelectT(func(kv linq.KeyValue) jen.Code {
			path := cast.ToString(kv.Key)
			var result []jen.Code

			linq.From(kv.Value.(*openapi3.PathItem).Operations()).
				SelectT(func(kv linq.KeyValue) jen.Code {
					name := generator.normalizer.normalizeOperationName(path, cast.ToString(kv.Key))
					return jen.Null().Add(generator.normalizer.doubleLineAfterEachElement(generator.responseType(name))...)
				}).ToSlice(&result)

			result = generator.normalizer.doubleLineAfterEachElement(result...)

			return jen.Null().Add(result...)
		}).ToSlice(&result)

	result = generator.normalizer.doubleLineAfterEachElement(result...)
	return jen.Null().Add(result...)
}

func (generator *Generator) handlersInterfaces(swagger *openapi3.Swagger) jen.Code {
	var result []jen.Code

	linq.From(swagger.Paths).
		SelectManyT(
			func(kv linq.KeyValue) linq.Query {
				path := cast.ToString(kv.Key)
				taggedInterfaceMethods := map[string][]jen.Code{}

				linq.From(kv.Value.(*openapi3.PathItem).Operations()).
					GroupByT(func(kv linq.KeyValue) string { return kv.Value.(*openapi3.Operation).Tags[0] },
						func(kv linq.KeyValue) []jen.Code {
							name := generator.normalizer.normalizeOperationName(path, cast.ToString(kv.Key))
							operation := kv.Value.(*openapi3.Operation)

							if operation.RequestBody == nil {
								return []jen.Code{jen.Id(name).Params(jen.Qual("context", "Context"), jen.Id(name+"Request")).Params(jen.Id(name + "Response"))}
							}

							//if we have only one content type we dont need to have it inside function name
							if len(operation.RequestBody.Value.Content) == 1 {
								return []jen.Code{jen.Id(name).Params(jen.Qual("context", "Context"), jen.Id(name+"Request")).Params(jen.Id(name + "Response"))}
							}

							var contentTypedInterfaceMethods []jen.Code
							linq.From(operation.RequestBody.Value.Content).
								SelectT(func(kv linq.KeyValue) jen.Code {
									contentTypedName := name + generator.normalizer.contentType(cast.ToString(kv.Key))
									return jen.Id(contentTypedName).Params(jen.Qual("context", "Context"), jen.Id(contentTypedName+"Request")).Params(jen.Id(name + "Response"))
								}).ToSlice(&contentTypedInterfaceMethods)

							return contentTypedInterfaceMethods
						}).
					ToMapByT(&taggedInterfaceMethods,
						func(kv linq.Group) interface{} { return kv.Key },
						func(kv linq.Group) (grouped []jen.Code) {
							linq.From(kv.Group).SelectMany(func(i interface{}) linq.Query { return linq.From(i) }).ToSlice(&grouped)
							return
						},
					)

				return linq.From(taggedInterfaceMethods)
			}).
		GroupByT(
			func(kv linq.KeyValue) interface{} { return kv.Key },
			func(kv linq.KeyValue) interface{} { return kv.Value },
		).
		SelectT(func(kv linq.Group) jen.Code {
			var grouped []jen.Code
			linq.From(kv.Group).SelectMany(func(i interface{}) linq.Query { return linq.From(i) }).ToSlice(&grouped)
			return jen.Type().Id(strings.Title(cast.ToString(kv.Key)) + "Service").Interface(grouped...)
		}).
		ToSlice(&result)

	return jen.Null().Add(generator.normalizer.doubleLineAfterEachElement(result...)...)
}

func (generator *Generator) responseStruct() jen.Code {
	return jen.Type().Id("response").Struct(
		jen.Id("statusCode").Id("int"),
		jen.Id("body").Interface(),
		jen.Id("contentType").Id("string"),
		jen.Id("redirectURL").Id("string"),
		jen.Id("headers").Map(jen.Id("string")).Id("string"),
	).Add(jen.Line().Line()).
		Add(jen.Type().Id("responseInterface").Interface(
			jen.Id("statusCode").Params().Id("int"),
			jen.Id("body").Params().Interface(),
			jen.Id("contentType").Params().Id("string"),
			jen.Id("redirectURL").Params().Id("string"),
			jen.Id("headers").Params().Map(jen.Id("string")).Id("string")))
}

func (generator *Generator) responseInterface(name string) jen.Code {
	name = generator.normalizer.decapitalize(name)

	return jen.Type().Id(name + "Response").Interface(jen.Id(name + "Response").Params())
}

func (generator *Generator) responseType(name string) jen.Code {
	decapicalizedName := generator.normalizer.decapitalize(name)
	capitalizedName := strings.Title(name)

	interfaceDeclaration := jen.Type().Id(capitalizedName+"Response").Interface(
		jen.Id("responseInterface"),
		jen.Id(decapicalizedName+"Response").Params(),
	)

	declaration := jen.Type().Id(decapicalizedName + "Response").Struct(jen.Id("response"))
	interfaceImplementation := jen.Func().Params(jen.Id(decapicalizedName+"Response")).Id(decapicalizedName+"Response").Params().Block().
		Add(jen.Line(), jen.Line()).
		Add(jen.Func().Params(
			jen.Id("response").Id(decapicalizedName+"Response")).Id("statusCode").Params().Params(
			jen.Id("int")).Block(
			jen.Return().Id("response").Dot("response").Dot("statusCode"),
		)).
		Add(jen.Line(), jen.Line()).
		Add(jen.Func().Params(
			jen.Id("response").Id(decapicalizedName+"Response")).Id("body").Params().Params(jen.Interface()).Block(
			jen.Return().Id("response").Dot("response").Dot("body"),
		)).
		Add(jen.Line(), jen.Line()).
		Add(jen.Func().Params(
			jen.Id("response").Id(decapicalizedName+"Response")).Id("contentType").Params().Params(
			jen.Id("string")).Block(
			jen.Return().Id("response").Dot("response").Dot("contentType"),
		)).
		Add(jen.Line(), jen.Line()).
		Add(jen.Func().Params(
			jen.Id("response").Id(decapicalizedName+"Response")).Id("redirectURL").Params().Params(
			jen.Id("string")).Block(
			jen.Return().Id("response").Dot("response").Dot("redirectURL"),
		)).
		Add(jen.Line(), jen.Line()).
		Add(jen.Func().Params(
			jen.Id("response").Id(decapicalizedName + "Response")).Id("headers").Params().Params(
			jen.Map(jen.Id("string")).Id("string")).Block(
			jen.Return().Id("response").Dot("response").Dot("headers"),
		))

	return jen.Null().Add(generator.normalizer.doubleLineAfterEachElement(interfaceDeclaration, declaration, interfaceImplementation)...)
}

func (generator *Generator) responseImplementationFunc(name string) jen.Code {
	return jen.Func().Params(jen.Id(strings.Title(name) + "Response")).Id(generator.normalizer.decapitalize(name) + "Response").Params().Block()
}

//if hasHeaders && hasContentTypes
//N statusCode -> headersStruct -> M contentType -> body -> assemble

//if hasHeaders && !hasContentTypes
//N statusCode -> headersStruct -> assemble

//if !hasHeaders && hasContentTypes
//N statusCode -> M contentType -> body -> assemble

//if !hasHeaders && !hasContentTypes
//N statusCode -> assemble
func (generator *Generator) responseBuilders(operationStruct operationStruct) jen.Code {
	builderConstructorName := generator.builderConstructorName(operationStruct.Name)
	statusCodesBuilderName := generator.statusCodesBuilderName(operationStruct.PrivateName)

	structBuilder := jen.Type().Id(statusCodesBuilderName).Struct(jen.Id("response"))
	structConstructor := jen.Func().Id(builderConstructorName).Params().Params(
		jen.Op("*").Id(statusCodesBuilderName)).Block(
		jen.Return().Id("new").Call(jen.Id(statusCodesBuilderName)),
	)

	var results []jen.Code

	linq.From(operationStruct.Responses).
		SelectT(func(resp operationResponse) (results []jen.Code) {
			hasHeaders := len(resp.Headers) > 0
			hasContentTypes := len(resp.ContentTypeBodyNameMap) > 0
			isRedirect := resp.StatusCode == "302"

			//OK
			if !hasHeaders && !hasContentTypes {
				//assembler struct
				assemblerName := generator.assemblerName(operationStruct.Name + resp.StatusCode)
				results = append(results, jen.Type().Id(assemblerName).Struct(jen.Id("response")))

				//statusCode -> assembler
				if isRedirect {
					results = append(results, jen.Func().Params(
						jen.Id("builder").Op("*").Id(statusCodesBuilderName)).Id("StatusCode"+resp.StatusCode).Params(jen.Id("redirectURL").String()).Params(
						jen.Op("*").Id(assemblerName)).Block(
						jen.Id("builder").Dot("response").Dot("statusCode").Op("=").Lit(cast.ToInt(resp.StatusCode)),
						jen.Id("builder").Dot("response").Dot("redirectURL").Op("=").Id("redirectURL"),
						jen.Line().Return().Op("&").Id(assemblerName).Values(jen.Id("response").Op(":").Id("builder").Dot("response")),
					))
				} else {
					results = append(results, jen.Func().Params(
						jen.Id("builder").Op("*").Id(statusCodesBuilderName)).Id("StatusCode"+resp.StatusCode).Params().Params(
						jen.Op("*").Id(assemblerName)).Block(
						jen.Id("builder").Dot("response").Dot("statusCode").Op("=").Lit(cast.ToInt(resp.StatusCode)),
						jen.Line().Return().Op("&").Id(assemblerName).Values(jen.Id("response").Op(":").Id("builder").Dot("response")),
					))
				}

				//build
				results = append(results, jen.Func().Params(
					jen.Id("builder").Op("*").Id(assemblerName)).Id("Build").Params().Params(
					jen.Id(operationStruct.InterfaceResponseName)).Block(
					jen.Return().Id(operationStruct.ResponseName).Values(jen.Id("response").Op(":").Id("builder").Dot("response"))),
				)

				return
			}

			if hasHeaders && !hasContentTypes {
				headersStructName := generator.headersStructName(operationStruct.Name + resp.StatusCode)
				headersBuilderName := generator.headersBuilderName(operationStruct.PrivateName + resp.StatusCode)

				//headers struct
				results = append(results, generator.headersStruct(headersStructName, resp.Headers))

				//statusCode -> headersStruct
				results = append(results, jen.Func().Params(
					jen.Id("builder").Op("*").Id(statusCodesBuilderName)).Id("StatusCode"+resp.StatusCode).Params().Params(
					jen.Op("*").Id(headersBuilderName)).Block(
					jen.Id("builder").Dot("response").Dot("statusCode").Op("=").Lit(cast.ToInt(resp.StatusCode)),
					jen.Line().Return().Op("&").Id(headersBuilderName).Values(jen.Id("response").Op(":").Id("builder").Dot("response")),
				))

				//headersStruct struct
				results = append(results, jen.Type().Id(headersBuilderName).Struct(jen.Id("response")))

				assemblerName := generator.assemblerName(operationStruct.Name + resp.StatusCode)

				//headers -> assemble
				results = append(results,
					jen.Func().Params(
						jen.Id("builder").Op("*").Id(headersBuilderName)).Id("Headers").Params(
						jen.Id("headers").Id(headersStructName)).Params(
						jen.Op("*").Id(assemblerName)).Block(
						jen.Id("builder").Dot("headers").Op("=").Id("headers").Dot("toMap").Call(),
						jen.Line().Return().Op("&").Id(assemblerName).Values(jen.Id("response").Op(":").Id("builder").Dot("response")),
					))

				//assembler struct
				results = append(results, jen.Type().Id(assemblerName).Struct(jen.Id("response")))

				//assemble
				results = append(results, jen.Func().Params(
					jen.Id("builder").Op("*").Id(assemblerName)).Id("Build").Params().Params(
					jen.Id(operationStruct.InterfaceResponseName)).Block(
					jen.Return().Id(operationStruct.ResponseName).Values(jen.Id("response").Op(":").Id("builder").Dot("response"))),
				)

				return
			}

			if !hasHeaders && hasContentTypes {
				contentTypeBuilderName := generator.contentTypeBuilderName(operationStruct.PrivateName + resp.StatusCode)

				//statusCode -> contentType
				results = append(results, jen.Func().Params(
					jen.Id("builder").Op("*").Id(statusCodesBuilderName)).Id("StatusCode"+resp.StatusCode).Params().Params(
					jen.Op("*").Id(contentTypeBuilderName)).Block(
					jen.Id("builder").Dot("response").Dot("statusCode").Op("=").Lit(cast.ToInt(resp.StatusCode)),
					jen.Line().Return().Op("&").Id(contentTypeBuilderName).Values(jen.Id("response").Op(":").Id("builder").Dot("response")),
				))

				//content-type struct
				results = append(results, jen.Type().Id(contentTypeBuilderName).Struct(jen.Id("response")))

				var contentTypeBodyBuild []jen.Code

				//content-types -> body -> build
				linq.From(resp.ContentTypeBodyNameMap).
					SelectT(func(kv linq.KeyValue) jen.Code {
						var result []jen.Code

						contentType := cast.ToString(kv.Key)
						contentTypeFuncName := generator.contentTypeFuncName(contentType)
						bodyBuilderName := generator.bodyGeneratorName(operationStruct.PrivateName+resp.StatusCode, contentType)

						//content-type -> body
						result = append(result, jen.Func().Params(
							jen.Id("builder").Op("*").Id(contentTypeBuilderName)).Id(contentTypeFuncName).Params().Params(
							jen.Op("*").Id(bodyBuilderName)).Block(
							jen.Id("builder").Dot("response").Dot("contentType").Op("=").Lit(contentType),
							jen.Line().Return().Op("&").Id(bodyBuilderName).Values(jen.Id("response").Op(":").Id("builder").Dot("response")),
						))

						//body struct
						result = append(result, jen.Type().Id(bodyBuilderName).Struct(jen.Id("response")))

						assemblerName := generator.assemblerName(operationStruct.Name + resp.StatusCode + generator.normalizer.contentType(contentType))

						//body builder
						result = append(result, jen.Func().Params(
							jen.Id("builder").Op("*").Id(bodyBuilderName)).Id("Body").Params(
							jen.Id("body").Qual(generator.config.ComponentsPackage, cast.ToString(kv.Value))).Params(
							jen.Op("*").Id(assemblerName)).Block(
							jen.Id("builder").Dot("response").Dot("body").Op("=").Id("body"),
							jen.Line().Return().Op("&").Id(assemblerName).Values(jen.Id("response").Op(":").Id("builder").Dot("response")),
						))

						//assembler struct
						results = append(results, jen.Type().Id(assemblerName).Struct(jen.Id("response")))

						//assemble
						results = append(results, jen.Func().Params(
							jen.Id("builder").Op("*").Id(assemblerName)).Id("Build").Params().Params(
							jen.Id(operationStruct.InterfaceResponseName)).Block(
							jen.Return().Id(operationStruct.ResponseName).Values(jen.Id("response").Op(":").Id("builder").Dot("response"))),
						)

						return jen.Null().Add(generator.normalizer.doubleLineAfterEachElement(result...)...)
					}).ToSlice(&contentTypeBodyBuild)

				results = generator.normalizer.doubleLineAfterEachElement(append(results, contentTypeBodyBuild...)...)

				return
			}

			if hasHeaders && hasContentTypes {
				headersStructName := generator.headersStructName(operationStruct.Name + resp.StatusCode)
				headersBuilderName := generator.headersBuilderName(operationStruct.PrivateName + resp.StatusCode)

				//statusCode -> headers
				results = append(results, jen.Func().Params(
					jen.Id("builder").Op("*").Id(statusCodesBuilderName)).Id("StatusCode"+resp.StatusCode).Params().Params(
					jen.Op("*").Id(headersBuilderName)).Block(
					jen.Id("builder").Dot("response").Dot("statusCode").Op("=").Lit(cast.ToInt(resp.StatusCode)),
					jen.Line().Return().Op("&").Id(headersBuilderName).Values(jen.Id("response").Op(":").Id("builder").Dot("response")),
				))

				//headers struct
				results = append(results, generator.headersStruct(headersStructName, resp.Headers))

				//headers builder struct
				results = append(results, jen.Type().Id(headersBuilderName).Struct(jen.Id("response")))

				//headers -> content-type
				contentTypeBuilderName := generator.contentTypeBuilderName(operationStruct.PrivateName + resp.StatusCode)
				results = append(results,
					jen.Func().Params(
						jen.Id("builder").Op("*").Id(headersBuilderName)).Id("Headers").Params(
						jen.Id("headers").Id(headersStructName)).Params(
						jen.Op("*").Id(contentTypeBuilderName)).Block(
						jen.Id("builder").Dot("headers").Op("=").Id("headers").Dot("toMap").Call(),
						jen.Line().Return().Op("&").Id(contentTypeBuilderName).Values(jen.Id("response").Op(":").Id("builder").Dot("response")),
					))

				//content-type struct
				results = append(results, jen.Type().Id(contentTypeBuilderName).Struct(jen.Id("response")))

				var contentTypeBodyBuild []jen.Code

				//content-types -> body -> build
				linq.From(resp.ContentTypeBodyNameMap).
					SelectT(func(kv linq.KeyValue) jen.Code {
						var result []jen.Code

						contentType := cast.ToString(kv.Key)
						contentTypeFuncName := generator.contentTypeFuncName(contentType)
						bodyBuilderName := generator.bodyGeneratorName(operationStruct.PrivateName+resp.StatusCode, contentType)

						//content-type -> body
						result = append(result, jen.Func().Params(
							jen.Id("builder").Op("*").Id(contentTypeBuilderName)).Id(contentTypeFuncName).Params().Params(
							jen.Op("*").Id(bodyBuilderName)).Block(
							jen.Id("builder").Dot("response").Dot("contentType").Op("=").Lit(contentType),
							jen.Line().Return().Op("&").Id(bodyBuilderName).Values(jen.Id("response").Op(":").Id("builder").Dot("response")),
						))

						//body struct
						result = append(result, jen.Type().Id(bodyBuilderName).Struct(jen.Id("response")))

						assemblerName := generator.assemblerName(operationStruct.Name + resp.StatusCode + generator.normalizer.contentType(contentType))

						//body builder
						result = append(result, jen.Func().Params(
							jen.Id("builder").Op("*").Id(bodyBuilderName)).Id("Body").Params(
							jen.Id("body").Qual(generator.config.ComponentsPackage, cast.ToString(kv.Value))).Params(
							jen.Op("*").Id(assemblerName)).Block(
							jen.Id("builder").Dot("response").Dot("body").Op("=").Id("body"),
							jen.Line().Return().Op("&").Id(assemblerName).Values(jen.Id("response").Op(":").Id("builder").Dot("response")),
						))

						//assembler struct
						results = append(results, jen.Type().Id(assemblerName).Struct(jen.Id("response")))

						//assemble
						results = append(results, jen.Func().Params(
							jen.Id("builder").Op("*").Id(assemblerName)).Id("Build").Params().Params(
							jen.Id(operationStruct.InterfaceResponseName)).Block(
							jen.Return().Id(operationStruct.ResponseName).Values(jen.Id("response").Op(":").Id("builder").Dot("response"))),
						)

						return jen.Null().Add(generator.normalizer.doubleLineAfterEachElement(result...)...)
					}).ToSlice(&contentTypeBodyBuild)

				results = generator.normalizer.doubleLineAfterEachElement(append(results, contentTypeBodyBuild...)...)
			}
			return
		}).
		SelectManyT(func(builders []jen.Code) linq.Query { return linq.From(builders) }).
		ToSlice(&results)

	return jen.Null().Add(generator.normalizer.doubleLineAfterEachElement(append([]jen.Code{structBuilder, structConstructor}, results...)...)...)
}

func (generator *Generator) securitySchemas(swagger *openapi3.Swagger) jen.Code {
	code := jen.Type().Id("SecurityScheme").Id("string").Line().Line()

	var consts []jen.Code
	linq.From(swagger.Components.SecuritySchemes).
		SelectT(func(kv linq.KeyValue) jen.Code {
			name := strings.Title(cast.ToString(kv.Key))
			return jen.Id("SecurityScheme" + name).Id("SecurityScheme").Op("=").Lit(name)
		}).
		ToSlice(&consts)

	code = code.Const().Defs(consts...).Line().Line()

	code = code.Line().Line().
		Type().Id("securityProcessor").Struct(
		jen.Id("scheme").Id("SecurityScheme"),
		jen.Id("extract").Func().Params(jen.Id("r").Op("*").Qual("net/http", "Request")).
			Params(jen.Id("string"), jen.Id("bool")),
		jen.Id("handle").Func().Params(jen.Id("r").Op("*").Qual("net/http", "Request"),
			jen.Id("scheme").Id("SecurityScheme"),
			jen.Id("value").Id("string")).Params(
			jen.Id("error")))

	var extractorsHeadersFuncs []jen.Code
	linq.From(swagger.Components.SecuritySchemes).
		SelectT(func(kv linq.KeyValue) jen.Code {
			name := generator.normalizer.normalize(cast.ToString(kv.Key))
			schema := kv.Value.(*openapi3.SecuritySchemeRef)

			if schema.Value.Type == "http" {
				ifStatement := jen.Null()
				assignment := jen.Null()
				if schema.Value.Scheme == "bearer" {
					ifStatement = ifStatement.Op("!").Qual("strings", "HasPrefix").Call(jen.Id("value"), jen.Lit("Bearer "))
					assignment = assignment.Id("value").Op("=").Id("value").Index(jen.Lit(7), jen.Empty())
				} else {
					ifStatement = ifStatement.Op("!").Qual("strings", "HasPrefix").Call(jen.Id("value"), jen.Lit("Basic "))
					assignment = assignment.Id("value").Op("=").Id("value").Index(jen.Lit(6), jen.Empty())
				}

				return jen.Line().Id("SecurityScheme"+strings.Title(name)).Op(":").Func().Params(
					jen.Id("r").Op("*").Qual("net/http", "Request")).Params(jen.Id("string"),
					jen.Id("bool")).Block(
					jen.Id("value").Op(":=").Id("r").Dot("Header").Dot("Get").Call(jen.Lit("Authorization")).Line(),
					jen.If(ifStatement).Block(jen.Return().List(jen.Lit(""), jen.Id("false"))).Line(),
					assignment.Line(),
					jen.Return().List(jen.Id("value"), jen.Id("value").Op("!=").Lit("")))
			}

			if schema.Value.Type == "apiKey" {
				return jen.Line().Id("SecurityScheme"+strings.Title(name)).Op(":").Func().Params(
					jen.Id("r").Op("*").Qual("net/http",
						"Request")).Params(
					jen.Id("string"),
					jen.Id("bool")).Block(
					jen.Id("value").Op(":=").Id("r").Dot("Header").Dot("Get").Call(jen.Lit(schema.Value.Name)).Line(),
					jen.Return().List(jen.Id("value"),
						jen.Id("value").Op("!=").Lit("")))
			}

			return jen.Null()
		}).ToSlice(&extractorsHeadersFuncs)

	extractorsHeadersFuncs = append(extractorsHeadersFuncs, jen.Line())

	code = code.Line().Line().Var().Id("securityExtractorsFuncs").Op("=").Map(jen.Id("SecurityScheme")).Func().Params(
		jen.Id("r").Op("*").Qual("net/http", "Request")).Params(jen.Id("string"),
		jen.Id("bool")).Values(extractorsHeadersFuncs...)

	var interfaceFuncs []jen.Code
	linq.From(swagger.Components.SecuritySchemes).
		SelectT(func(kv linq.KeyValue) interface{} { return kv.Key }).
		SelectT(func(name string) jen.Code {
			return jen.Id("SecurityScheme"+strings.Title(name)).Params(
				jen.Id("r").Op("*").Qual("net/http",
					"Request"),
				jen.Id("scheme").Id("SecurityScheme"),
				jen.Id("value").Id("string")).Params(
				jen.Id("error"))
		}).ToSlice(&interfaceFuncs)

	code = code.Line().Line().Type().Id("SecuritySchemas").Interface(interfaceFuncs...)

	code = code.Line().Line().Type().Id("SecurityCheckResult").Struct(
		jen.Id("Scheme").Id("SecurityScheme"),
		jen.Id("Value").Id("string"),
	)

	return code
}

func (generator *Generator) headersStruct(name string, headers map[string]*openapi3.HeaderRef) jen.Code {
	if len(headers) == 0 {
		return jen.Null()
	}

	var headersCode []jen.Code

	linq.From(headers).SelectT(func(kv linq.KeyValue) jen.Code {
		name := generator.normalizer.normalize(cast.ToString(kv.Key))
		field := jen.Id(name)

		generator.typee.fillGoType(field, name, kv.Value.(*openapi3.HeaderRef).Value.Schema, false, false)

		return field
	}).ToSlice(&headersCode)

	headersStruct := jen.Type().Id(name).Struct(headersCode...)

	var headersMapCode []jen.Code

	linq.From(headers).SelectT(func(kv linq.KeyValue) jen.Code {
		key := cast.ToString(kv.Key)
		name := generator.normalizer.normalize(key)
		return jen.Lit(key).Op(":").Qual("github.com/spf13/cast", "ToString").Call(jen.Id("headers").Dot(name))
	}).ToSlice(&headersMapCode)

	headersToMap := jen.Func().Params(
		jen.Id("headers").Id(name)).Id("toMap").Params().Params(
		jen.Map(jen.Id("string")).Id("string")).Block(
		jen.Return().Map(jen.Id("string")).Id("string").
			Values(headersMapCode...))

	return jen.Null().Add(generator.normalizer.doubleLineAfterEachElement(headersStruct, headersToMap)...)
}

func (generator *Generator) specCode(swagger *openapi3.Swagger) jen.Code {
	specJson, err := json.Marshal(swagger)
	if err != nil {
		panic(err)
	}

	minifiedJson, err := minify.JSON(string(specJson))
	if err != nil {
		panic(err)
	}

	return jen.Var().Id("spec").Op("=").Index().Id("byte").Call(jen.Lit(minifiedJson)).
		Line().Line().
		Func().Id("Spec").Params(
		jen.Id("w").Qual("net/http",
			"ResponseWriter"),
		jen.Id("_").Op("*").Qual("net/http",
			"Request")).Block(
		jen.Id("w").Dot("Header").Call().Dot("Add").Call(jen.Lit("Content-Type"),
			jen.Lit("application/json")),
		jen.Id("w").Dot("Write").Call(jen.Id("spec")))
}

func (*Generator) builderConstructorName(name string) string {
	return name + "ResponseBuilder"
}

func (*Generator) statusCodesBuilderName(name string) string {
	return name + "StatusCodeResponseBuilder"
}

func (*Generator) headersBuilderName(name string) string {
	return name + "HeadersBuilder"
}

func (*Generator) headersStructName(name string) string {
	return name + "Headers"
}

func (*Generator) assemblerName(name string) string {
	return name + "ResponseBuilder"
}

func (generator *Generator) contentTypeBuilderName(name string) string {
	return name + "ContentTypeBuilder"
}

func (generator *Generator) contentTypeFuncName(contentType string) string {
	return generator.normalizer.contentType(contentType)
}

func (generator *Generator) bodyGeneratorName(name string, contentType string) string {
	return name + generator.normalizer.contentType(contentType) + "BodyBuilder"
}

func (generator *Generator) trimPackagePath(from string) string {
	index := strings.LastIndex(from, "/")
	if index < 0 {
		return from
	}

	return from[index+1:]
}
