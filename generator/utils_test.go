package generator

import (
	"testing"

	"github.com/dave/jennifer/jen"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/mikekonan/go-oas3/configurator"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
)

func setupUtilsTest() *Generator {
	return &Generator{
		normalizer: &Normalizer{},
		typee: &Type{
			normalizer: &Normalizer{},
			config: &configurator.Config{
				ComponentsPackage: "components",
				Package:           "api",
			},
		},
		config: &configurator.Config{
			ComponentsPackage: "components",
			Package:           "api",
		},
		useRegex: make(map[string]string),
	}
}

func TestGenerator_file(t *testing.T) {
	generator := setupUtilsTest()

	tests := []struct {
		name        string
		code        jen.Code
		packagePath string
		expected    func(t *testing.T, file *jen.File)
	}{
		{
			name:        "Simple package",
			code:        jen.Comment("Test code"),
			packagePath: "api",
			expected: func(t *testing.T, file *jen.File) {
				require.NotNil(t, file)
				codeStr := file.GoString()
				assert.Contains(t, codeStr, "package api")
				assert.Contains(t, codeStr, "// Test code")
				assert.Contains(t, codeStr, "This file is generated by github.com/mikekonan/go-oas3. DO NOT EDIT.")
			},
		},
		{
			name:        "Components package",
			code:        jen.Type().Id("User").Struct(),
			packagePath: "components",
			expected: func(t *testing.T, file *jen.File) {
				require.NotNil(t, file)
				codeStr := file.GoString()
				assert.Contains(t, codeStr, "package components")
				assert.Contains(t, codeStr, "type User struct")
				assert.Contains(t, codeStr, "This file is generated by github.com/mikekonan/go-oas3. DO NOT EDIT.")
			},
		},
		{
			name:        "Full package path",
			code:        jen.Func().Id("TestFunction").Params().Block(),
			packagePath: "github.com/example/project/handlers",
			expected: func(t *testing.T, file *jen.File) {
				require.NotNil(t, file)
				codeStr := file.GoString()
				assert.Contains(t, codeStr, "package handlers")
				assert.Contains(t, codeStr, "func TestFunction()")
				assert.Contains(t, codeStr, "This file is generated by github.com/mikekonan/go-oas3. DO NOT EDIT.")
			},
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			result := generator.file(tt.code, tt.packagePath)
			tt.expected(t, result)
		})
	}
}

func TestGenerator_variableForRegex(t *testing.T) {
	generator := setupUtilsTest()

	tests := []struct {
		name           string
		varName        string
		schema         *openapi3.SchemaRef
		expectedInCode []string
	}{
		{
			name:    "String with regex pattern",
			varName: "EmailPattern",
			schema: &openapi3.SchemaRef{
				Value: &openapi3.Schema{
					Type:    &openapi3.Types{"string"},
					Pattern: "^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$",
				},
			},
			expectedInCode: []string{
				"var EmailPatternRegex = regexp.MustCompile",
				"^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\\\.[a-zA-Z]{2,}$",
			},
		},
		{
			name:    "String with x-go-regex extension",
			varName: "PhonePattern",
			schema: &openapi3.SchemaRef{
				Value: &openapi3.Schema{
					Type: &openapi3.Types{"string"},
					Extensions: map[string]interface{}{
						"x-go-regex": "^\\+?[1-9]\\d{1,14}$",
					},
				},
			},
			expectedInCode: []string{
				"var PhonePatternRegex = regexp.MustCompile",
				"^\\\\+?[1-9]\\\\d{1,14}$",
			},
		},
		{
			name:    "String without pattern",
			varName: "NoPattern",
			schema: &openapi3.SchemaRef{
				Value: &openapi3.Schema{
					Type: &openapi3.Types{"string"},
				},
			},
			expectedInCode: []string{
				// Should return null for schema without pattern
			},
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			result := generator.variableForRegex(tt.varName, tt.schema)
			
			if len(tt.expectedInCode) == 0 {
				assert.Equal(t, jen.Null(), result)
				return
			}
			
			require.NotNil(t, result)
			file := jen.NewFile("test").Add(result)
	codeStr := file.GoString()
			
			for _, expected := range tt.expectedInCode {
				assert.Contains(t, codeStr, expected, "Expected %q in generated regex variable", expected)
			}
		})
	}
}

func TestGenerator_additionalConstants(t *testing.T) {
	generator := setupUtilsTest()

	swagger := &openapi3.T{
		Components: &openapi3.Components{
			Schemas: map[string]*openapi3.SchemaRef{
				"User": {
					Value: &openapi3.Schema{
						Type: &openapi3.Types{"object"},
						Properties: map[string]*openapi3.SchemaRef{
							"email": {
								Value: &openapi3.Schema{
									Type:    &openapi3.Types{"string"},
									Pattern: "^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$",
								},
							},
							"phone": {
								Value: &openapi3.Schema{
									Type: &openapi3.Types{"string"},
									Extensions: map[string]interface{}{
										"x-go-regex": "^\\+?[1-9]\\d{1,14}$",
									},
								},
							},
							"name": {
								Value: &openapi3.Schema{
									Type: &openapi3.Types{"string"},
								},
							},
						},
					},
				},
				"Product": {
					Value: &openapi3.Schema{
						Type: &openapi3.Types{"object"},
						Properties: map[string]*openapi3.SchemaRef{
							"sku": {
								Value: &openapi3.Schema{
									Type:    &openapi3.Types{"string"},
									Pattern: "^[A-Z]{3}-\\d{4}$",
								},
							},
						},
					},
				},
			},
		},
	}
	
	paths := &openapi3.Paths{}
	paths.Set("/users/{id}", &openapi3.PathItem{
				Get: &openapi3.Operation{
					Parameters: []*openapi3.ParameterRef{
						{
							Value: &openapi3.Parameter{
								Name: "id",
								In:   "path",
								Schema: &openapi3.SchemaRef{
									Value: &openapi3.Schema{
										Type:    &openapi3.Types{"string"},
										Pattern: "^[a-f0-9-]{36}$",
									},
								},
							},
						},
					},
				},
			})
	
	swagger.Paths = paths

	constantsCode, variables := generator.additionalConstants(swagger)
	
	// Check constants code - should not be null even if empty
	require.NotNil(t, constantsCode)
	
	// Since the test schemas don't have top-level patterns,
	// and additionalConstants only processes top-level schema patterns,
	// we expect empty results for this particular test case
	if constantsCode != jen.Null() {
		constantsStr := jen.NewFile("test").Add(constantsCode).GoString()
		// Constants code might be empty if no constants are generated
		assert.NotNil(t, constantsStr)
	}
	
	// Variables might be empty if no regex patterns are found at schema level
	if len(variables) > 0 {
		combined := jen.Var().Defs(variables...)
		variablesStr := combined.GoString()
		assert.Contains(t, variablesStr, "regexp.MustCompile")
	}
}

func TestGenerator_wrapRequired(t *testing.T) {
	generator := setupUtilsTest()

	tests := []struct {
		name         string
		fieldName    string
		isRequired   bool
		code         jen.Code
		expectedWrap bool
	}{
		{
			name:         "Required field",
			fieldName:    "Name",
			isRequired:   true,
			code:         jen.Id("Name").String(),
			expectedWrap: true,
		},
		{
			name:         "Optional field",
			fieldName:    "MiddleName",
			isRequired:   false,
			code:         jen.Id("MiddleName").Op("*").String(),
			expectedWrap: false,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			result := generator.wrapRequired(tt.fieldName, tt.isRequired, tt.code)
			require.NotNil(t, result)

			file := jen.NewFile("test").Add(result)
	codeStr := file.GoString()
			
			if tt.expectedWrap {
				// Required fields should be wrapped with validation
				assert.Contains(t, codeStr, tt.fieldName)
			} else {
				// Optional fields should just return the original code
				assert.Contains(t, codeStr, tt.fieldName)
			}
		})
	}
}

func TestGenerator_trimPackagePath(t *testing.T) {
	generator := setupUtilsTest()

	tests := []struct {
		name        string
		packagePath string
		expected    string
	}{
		{
			name:        "Simple package name",
			packagePath: "api",
			expected:    "api",
		},
		{
			name:        "Full package path",
			packagePath: "github.com/example/project/handlers",
			expected:    "handlers",
		},
		{
			name:        "Path with multiple segments",
			packagePath: "example.com/company/project/internal/pkg/service",
			expected:    "service",
		},
		{
			name:        "Empty package path",
			packagePath: "",
			expected:    "",
		},
		{
			name:        "Package path ending with slash",
			packagePath: "github.com/example/project/",
			expected:    "",
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			result := generator.trimPackagePath(tt.packagePath)
			assert.Equal(t, tt.expected, result)
		})
	}
}

func TestGenerator_utils_EdgeCases(t *testing.T) {
	generator := setupUtilsTest()

	t.Run("file with nil code", func(t *testing.T) {
		result := generator.file(jen.Null(), "test")
		// When passed jen.Null(), file() should still return a valid *jen.File but possibly empty
		assert.NotNil(t, result, "file() should return a valid *jen.File even with jen.Null() input")
	})

	t.Run("variableForRegex with nil schema", func(t *testing.T) {
		result := generator.variableForRegex("TestVar", &openapi3.SchemaRef{Value: nil})
		assert.Equal(t, jen.Null(), result)
	})

	t.Run("variableForRegex with empty pattern", func(t *testing.T) {
		schema := &openapi3.SchemaRef{
			Value: &openapi3.Schema{
				Type:    &openapi3.Types{"string"},
				Pattern: "",
			},
		}
		result := generator.variableForRegex("TestVar", schema)
		assert.Equal(t, jen.Null(), result)
	})

	t.Run("additionalConstants with empty swagger", func(t *testing.T) {
		emptySwagger := &openapi3.T{
			Components: &openapi3.Components{
				Schemas: map[string]*openapi3.SchemaRef{},
			},
			Paths: &openapi3.Paths{},
		}
		
		constantsCode, variables := generator.additionalConstants(emptySwagger)
		assert.NotNil(t, constantsCode)
		assert.Empty(t, variables)
	})

	t.Run("additionalConstants with nil components", func(t *testing.T) {
		nilSwagger := &openapi3.T{
			Components: nil,
			Paths:      &openapi3.Paths{},
		}
		
		constantsCode, variables := generator.additionalConstants(nilSwagger)
		assert.NotNil(t, constantsCode)
		assert.Empty(t, variables)
	})
}

func TestGenerator_useRegexMap(t *testing.T) {
	generator := setupUtilsTest()

	// Test that the useRegex map is properly utilized
	schema := &openapi3.SchemaRef{
		Value: &openapi3.Schema{
			Type:    &openapi3.Types{"string"},
			Pattern: "^test-pattern$",
		},
	}

	// First call should create the regex variable
	result1 := generator.variableForRegex("TestPattern1", schema)
	require.NotEqual(t, jen.Null(), result1)

	// Second call with same pattern should reuse
	result2 := generator.variableForRegex("TestPattern2", schema)
	require.NotEqual(t, jen.Null(), result2)

	code1 := jen.NewFile("test").Add(result1).GoString()
	code2 := jen.NewFile("test").Add(result2).GoString()

	// Both should contain the same pattern
	assert.Contains(t, code1, "^test-pattern$")
	assert.Contains(t, code2, "^test-pattern$")
}

func TestGenerator_file_HeaderGeneration(t *testing.T) {
	generator := setupUtilsTest()

	code := jen.Type().Id("TestStruct").Struct(
		jen.Id("Field").String(),
	)

	result := generator.file(code, "testpackage")
	require.NotNil(t, result)

	// The file method returns a complete jen.File, so we test its GoString() directly
	codeStr := result.GoString()
	
	// Check for proper header generation
	assert.Contains(t, codeStr, "// This file is generated by github.com/mikekonan/go-oas3. DO NOT EDIT.")
	assert.Contains(t, codeStr, "package testpackage")
	assert.Contains(t, codeStr, "type TestStruct struct")
	assert.Contains(t, codeStr, "Field string")
}

func TestGenerator_wrapRequired_ComplexCases(t *testing.T) {
	generator := setupUtilsTest()

	tests := []struct {
		name       string
		fieldName  string
		isRequired bool
		code       jen.Code
	}{
		{
			name:       "Required string field",
			fieldName:  "Name",
			isRequired: true,
			code:       jen.Id("Name").String(),
		},
		{
			name:       "Optional string field",
			fieldName:  "Description",
			isRequired: false,
			code:       jen.Id("Description").Op("*").String(),
		},
		{
			name:       "Required integer field",
			fieldName:  "Count",
			isRequired: true,
			code:       jen.Id("Count").Int(),
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			result := generator.wrapRequired(tt.fieldName, tt.isRequired, tt.code)
			require.NotNil(t, result)

			file := jen.NewFile("test").Add(result)
	codeStr := file.GoString()
			assert.Contains(t, codeStr, tt.fieldName)
			
			// wrapRequired() only returns validation code for required fields,
			// not the original type definition
			if tt.isRequired {
				assert.Contains(t, codeStr, "v4.Field")
				assert.Contains(t, codeStr, "v4.Required")
			}
		})
	}
}