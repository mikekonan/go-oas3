package generator

import (
	"strings"

	"github.com/dave/jennifer/jen"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/ahmetb/go-linq"
	"github.com/spf13/cast"
)

// file creates a jen.File with standard imports and header comments
func (generator *Generator) file(from jen.Code, packagePath string) *jen.File {
	file := jen.NewFilePathName(packagePath, generator.trimPackagePath(packagePath))
	file.HeaderComment("This file is generated by github.com/mikekonan/go-oas3. DO NOT EDIT.")
	file.ImportAlias("github.com/mikekonan/go-types/v2/country", "countries")
	file.ImportAlias("github.com/mikekonan/go-types/v2/currency", "currency")
	file.ImportAlias("github.com/go-ozzo/ozzo-validation/v4", "validation")
	file.ImportAlias("github.com/go-chi/chi/v5", "chi")

	file.Add(from)

	return file
}

// trimPackagePath extracts the package name from a full package path
func (generator *Generator) trimPackagePath(from string) string {
	index := strings.LastIndex(from, "/")
	if index < 0 {
		return from
	}

	return from[index+1:]
}

// variableForRegex generates regex validation variables for schemas
func (generator *Generator) variableForRegex(name string, schema *openapi3.SchemaRef) jen.Code {
	regexValue := generator.getXGoRegex(schema)
	if regexValue == "" {
		return jen.Null()
	}

	// Optimize regex generation by caching patterns
	if generator.useRegex == nil {
		generator.useRegex = make(map[string]string)
	}

	constantName := generator.normalizer.decapitalize(name + SuffixRegex)
	generator.useRegex[regexValue] = constantName

	return jen.Var().Id(constantName).Op("=").
		Qual(PackageRegexp, MethodMustCompile).Call(jen.Lit(regexValue))
}

// getXGoRegex extracts regex pattern from schema extensions or Pattern field
func (generator *Generator) getXGoRegex(schema *openapi3.SchemaRef) string {
	if schema == nil || schema.Value == nil {
		return ""
	}

	// Check x-go-regex extension first
	if len(schema.Value.Extensions) > 0 && schema.Value.Extensions[ExtGoRegex] != nil {
		return cast.ToString(schema.Value.Extensions[ExtGoRegex])
	}

	// Fall back to standard Pattern field
	if schema.Value.Pattern != "" {
		return schema.Value.Pattern
	}

	return ""
}

// getXGoStringTrimmable checks if string should be trimmed during processing
func (generator *Generator) getXGoStringTrimmable(schema *openapi3.SchemaRef) bool {
	if schema == nil || schema.Value == nil {
		return false
	}

	if len(schema.Value.Extensions) > 0 && schema.Value.Extensions[ExtGoStringTrimmable] != nil {
		return cast.ToBool(schema.Value.Extensions[ExtGoStringTrimmable])
	}

	return false
}

// additionalConstants generates additional constants needed for code generation
func (generator *Generator) additionalConstants(swagger *openapi3.T) (jen.Code, []jen.Code) {
	var componentsAdditionalConstants []jen.Code
	var parametersAdditionalConstants []jen.Code

	// Process schemas for regex patterns
	if swagger.Components != nil && swagger.Components.Schemas != nil {
		linq.From(swagger.Components.Schemas).
		SelectT(func(kv linq.KeyValue) jen.Code {
			name := generator.normalizer.normalize(cast.ToString(kv.Key))
			schemaRef := kv.Value.(*openapi3.SchemaRef)
			return generator.variableForRegex(name, schemaRef)
		}).
		WhereT(func(code jen.Code) bool {
			return code != jen.Null()
		}).
		ToSlice(&componentsAdditionalConstants)

		// Process nested properties for regex patterns
		var nestedSchemaConstants []jen.Code
		for _, schemaRef := range swagger.Components.Schemas {
			if schemaRef.Value != nil && schemaRef.Value.Properties != nil {
				for propName, propSchemaRef := range schemaRef.Value.Properties {
					propRegexName := generator.normalizer.normalize(propName)
					regexCode := generator.variableForRegex(propRegexName, propSchemaRef)
					if regexCode != jen.Null() {
						nestedSchemaConstants = append(nestedSchemaConstants, regexCode)
					}
				}
			}
		}
		componentsAdditionalConstants = append(componentsAdditionalConstants, nestedSchemaConstants...)
	}

	// Process global parameters for regex patterns
	if swagger.Components != nil && swagger.Components.Parameters != nil {
		var globalParamConstants []jen.Code
		for name, paramRef := range swagger.Components.Parameters {
			paramName := generator.normalizer.normalize(name)
			if paramRef.Value != nil && paramRef.Value.Schema != nil {
				regexCode := generator.variableForRegex(paramName, paramRef.Value.Schema)
				if regexCode != jen.Null() {
					globalParamConstants = append(globalParamConstants, regexCode)
				}
			}
		}
		componentsAdditionalConstants = append(componentsAdditionalConstants, globalParamConstants...)
	}

	// Process paths for additional constants
	linq.From(swagger.Paths.Map()).
		SelectManyT(func(kv linq.KeyValue) linq.Query {
			path := cast.ToString(kv.Key)
			var pathConstants []jen.Code

			linq.From(kv.Value.(*openapi3.PathItem).Operations()).
				SelectT(func(kv linq.KeyValue) jen.Code {
					name := generator.normalizer.normalizeOperationName(path, cast.ToString(kv.Key))
					operation := kv.Value.(*openapi3.Operation)

					// Generate constants for request body schemas
					if operation.RequestBody != nil {
						linq.From(operation.RequestBody.Value.Content).
							SelectT(func(kv linq.KeyValue) jen.Code {
								contentType := cast.ToString(kv.Key)
								mediaType := kv.Value.(*openapi3.MediaType)
								if mediaType.Schema != nil && mediaType.Schema.Ref == "" {
									constName := name + generator.normalizer.contentType(contentType) + SuffixRequestBody
									return generator.variableForRegex(constName, mediaType.Schema)
								}
								return jen.Null()
							}).
							WhereT(func(code jen.Code) bool {
								return code != jen.Null()
							}).
							ToSlice(&pathConstants)
					}

					return jen.Null()
				})

			return linq.From(pathConstants)
		}).
		ToSlice(&parametersAdditionalConstants)

	var componentsCode jen.Code
	if len(componentsAdditionalConstants) > 0 {
		componentsCode = jen.Add(generator.normalizer.doubleLineAfterEachElement(componentsAdditionalConstants...)...)
	} else {
		componentsCode = jen.Null()
	}

	return componentsCode, parametersAdditionalConstants
}

// wrapRequired wraps code with validation if required
func (generator *Generator) wrapRequired(name string, isRequired bool, code jen.Code) jen.Code {
	if isRequired {
		return jen.Qual("github.com/go-ozzo/ozzo-validation/v4", "Field").Call(
			jen.Op("&").Id(name),
			jen.Qual("github.com/go-ozzo/ozzo-validation/v4", "Required"),
		)
	}
	return code
}

// extractRefFromAllOf extracts reference from allOf schema compositions
func (generator *Generator) extractRefFromAllOf(schema *openapi3.SchemaRef) string {
	if schema == nil || schema.Value == nil || len(schema.Value.AllOf) == 0 {
		return ""
	}

	for _, s := range schema.Value.AllOf {
		if s.Ref != "" {
			return s.Ref
		}
	}
	return ""
}

// Builder name generation utilities

func (*Generator) assemblerName(name string) string {
	return name + "ResponseBuilder"
}