// This file is generated by github.com/mikekonan/go-oas3. DO NOT EDIT.

package example

import (
	"context"
	"encoding/json"
	"errors"
	"fmt"
	chi "github.com/go-chi/chi/v5"
	cast "github.com/spf13/cast"
	"io"
	"net/http"
	"strconv"
	"strings"
	"time"
)

type TransactionsService interface {
	DeleteTransactionsUUID(ctx context.Context, request *DeleteTransactionsUUIDRequest) *DeleteTransactionsUUIDResponse
	PostTransaction(ctx context.Context, request *PostTransactionRequest) *PostTransactionResponse
	PutTransaction(ctx context.Context, request *PutTransactionRequest) *PutTransactionResponse
}

type TransactionsRouter struct {
	service    TransactionsService
	router     *chi.Mux
	hooks      *Hooks
	processors []securityProcessor
}

func NewTransactionsRouter(service TransactionsService, processors ...securityProcessor) *TransactionsRouter {
	router := chi.NewMux()
	instance := &TransactionsRouter{service: service, router: router, hooks: &Hooks{}, processors: processors}
	return instance
}

func (router *TransactionsRouter) deleteTransactionsUUID(w http.ResponseWriter, r *http.Request) {
	var request DeleteTransactionsUUIDRequest

	XSignature := r.Header.Get("x-signature")
	if XSignature != "" {
		request.header.XSignature = &XSignature
	}
	XFingerprint := r.Header.Get("x-fingerprint")
	if XFingerprint == "" {
		err := fmt.Errorf("x-fingerprint is required")

		request.ProcessingResult = RequestProcessingResult{error: err, typee: HeaderParseFailed}
		if router.hooks.RequestHeaderParseFailed != nil {
			router.hooks.RequestHeaderParseFailed(r, "deleteTransactionsUUID", "x-fingerprint", request.ProcessingResult)
		}

		return
	}

	if !fingerprintRegex.MatchString(XFingerprint) {
		err := fmt.Errorf("x-fingerprint not matched by the '[0-9a-fA-F]+' regex")

		request.ProcessingResult = RequestProcessingResult{error: err, typee: HeaderParseFailed}
		if router.hooks.RequestHeaderParseFailed != nil {
			router.hooks.RequestHeaderParseFailed(r, "deleteTransactionsUUID", "x-fingerprint", request.ProcessingResult)
		}

		return
	}

	request.header.XFingerprint = XFingerprint

	UUID := chi.URLParam(r, "uuid")
	if UUID == "" {
		err := fmt.Errorf("uuid is required")

		request.ProcessingResult = RequestProcessingResult{error: err, typee: PathParseFailed}
		if router.hooks.RequestPathParseFailed != nil {
			router.hooks.RequestPathParseFailed(r, "deleteTransactionsUUID", "uuid", request.ProcessingResult)
		}

		return
	}

	request.path.UUID = UUID
	RegexParam := chi.URLParam(r, "regexParam")
	if RegexParam == "" {
		err := fmt.Errorf("regexParam is required")

		request.ProcessingResult = RequestProcessingResult{error: err, typee: PathParseFailed}
		if router.hooks.RequestPathParseFailed != nil {
			router.hooks.RequestPathParseFailed(r, "deleteTransactionsUUID", "regexParam", request.ProcessingResult)
		}

		return
	}

	if !regexParamRegex.MatchString(RegexParam) {
		err := fmt.Errorf("regexParam not matched by the '^[.?\\d]+$' regex")

		request.ProcessingResult = RequestProcessingResult{error: err, typee: PathParseFailed}
		if router.hooks.RequestPathParseFailed != nil {
			router.hooks.RequestPathParseFailed(r, "deleteTransactionsUUID", "regexParam", request.ProcessingResult)
		}

		return
	}

	request.path.RegexParam = RegexParam

	TimeParamStr := r.URL.Query().Get("timeParam")
	TimeParam, err := cast.ToTimeE(TimeParamStr)
	if err != nil {
		request.ProcessingResult = RequestProcessingResult{error: err, typee: QueryParseFailed}
		if router.hooks.RequestQueryParseFailed != nil {
			router.hooks.RequestQueryParseFailed(r, "deleteTransactionsUUID", "timeParam", request.ProcessingResult)
		}

		return
	}

	request.query.TimeParam = &TimeParam

	request = router.parseDeleteTransactionsUUIDRequest(r)

	response := router.service.DeleteTransactionsUUID(r.Context(), &request)
	response.WriteTo(w)
}

func (router *TransactionsRouter) parseDeleteTransactionsUUIDRequest(r *http.Request) (request DeleteTransactionsUUIDRequest) {
	request.ProcessingResult = RequestProcessingResult{typee: ParseSucceed}

	for _, processor := range router.processors {
		if processor.scheme == SecuritySchemeBearer {
			name, value, found := processor.extract(r)
			if !found {
				request.ProcessingResult = RequestProcessingResult{error: fmt.Errorf("security scheme not found"), typee: SecurityParseFailed}
				if router.hooks.RequestSecurityParseFailed != nil {
					router.hooks.RequestSecurityParseFailed(r, "DeleteTransactionsUUID", request.ProcessingResult)
				}
				return
			}

			if err := processor.handle(r, processor.scheme, name, value); err != nil {
				request.ProcessingResult = RequestProcessingResult{error: err, typee: SecurityCheckFailed}
				if router.hooks.RequestSecurityCheckFailed != nil {
					router.hooks.RequestSecurityCheckFailed(r, "DeleteTransactionsUUID", string(processor.scheme), request.ProcessingResult)
				}
				return
			}

			if router.hooks.RequestSecurityCheckCompleted != nil {
				router.hooks.RequestSecurityCheckCompleted(r, "DeleteTransactionsUUID", string(processor.scheme))
			}
			break
		}
	}
	for _, processor := range router.processors {
		if processor.scheme == SecuritySchemeCookie {
			name, value, found := processor.extract(r)
			if !found {
				request.ProcessingResult = RequestProcessingResult{error: fmt.Errorf("security scheme not found"), typee: SecurityParseFailed}
				if router.hooks.RequestSecurityParseFailed != nil {
					router.hooks.RequestSecurityParseFailed(r, "DeleteTransactionsUUID", request.ProcessingResult)
				}
				return
			}

			if err := processor.handle(r, processor.scheme, name, value); err != nil {
				request.ProcessingResult = RequestProcessingResult{error: err, typee: SecurityCheckFailed}
				if router.hooks.RequestSecurityCheckFailed != nil {
					router.hooks.RequestSecurityCheckFailed(r, "DeleteTransactionsUUID", string(processor.scheme), request.ProcessingResult)
				}
				return
			}

			if router.hooks.RequestSecurityCheckCompleted != nil {
				router.hooks.RequestSecurityCheckCompleted(r, "DeleteTransactionsUUID", string(processor.scheme))
			}
			break
		}
	}
	XSignature := r.Header.Get("x-signature")
	if XSignature != "" {
		request.header.XSignature = &XSignature
	}
	XFingerprint := r.Header.Get("x-fingerprint")
	if XFingerprint == "" {
		err := fmt.Errorf("x-fingerprint is required")

		request.ProcessingResult = RequestProcessingResult{error: err, typee: HeaderParseFailed}
		if router.hooks.RequestHeaderParseFailed != nil {
			router.hooks.RequestHeaderParseFailed(r, "DeleteTransactionsUUID", "x-fingerprint", request.ProcessingResult)
		}

		return
	}

	if !fingerprintRegex.MatchString(XFingerprint) {
		err := fmt.Errorf("x-fingerprint not matched by the '[0-9a-fA-F]+' regex")

		request.ProcessingResult = RequestProcessingResult{error: err, typee: HeaderParseFailed}
		if router.hooks.RequestHeaderParseFailed != nil {
			router.hooks.RequestHeaderParseFailed(r, "DeleteTransactionsUUID", "x-fingerprint", request.ProcessingResult)
		}

		return
	}

	request.header.XFingerprint = XFingerprint

	UUID := chi.URLParam(r, "uuid")
	if UUID == "" {
		err := fmt.Errorf("uuid is required")

		request.ProcessingResult = RequestProcessingResult{error: err, typee: PathParseFailed}
		if router.hooks.RequestPathParseFailed != nil {
			router.hooks.RequestPathParseFailed(r, "DeleteTransactionsUUID", "uuid", request.ProcessingResult)
		}

		return
	}

	request.path.UUID = UUID
	RegexParam := chi.URLParam(r, "regexParam")
	if RegexParam == "" {
		err := fmt.Errorf("regexParam is required")

		request.ProcessingResult = RequestProcessingResult{error: err, typee: PathParseFailed}
		if router.hooks.RequestPathParseFailed != nil {
			router.hooks.RequestPathParseFailed(r, "DeleteTransactionsUUID", "regexParam", request.ProcessingResult)
		}

		return
	}

	if !regexParamRegex.MatchString(RegexParam) {
		err := fmt.Errorf("regexParam not matched by the '^[.?\\d]+$' regex")

		request.ProcessingResult = RequestProcessingResult{error: err, typee: PathParseFailed}
		if router.hooks.RequestPathParseFailed != nil {
			router.hooks.RequestPathParseFailed(r, "DeleteTransactionsUUID", "regexParam", request.ProcessingResult)
		}

		return
	}

	request.path.RegexParam = RegexParam

	TimeParamStr := r.URL.Query().Get("timeParam")
	TimeParam, err := cast.ToTimeE(TimeParamStr)
	if err != nil {
		request.ProcessingResult = RequestProcessingResult{error: err, typee: QueryParseFailed}
		if router.hooks.RequestQueryParseFailed != nil {
			router.hooks.RequestQueryParseFailed(r, "DeleteTransactionsUUID", "timeParam", request.ProcessingResult)
		}

		return
	}

	request.query.TimeParam = &TimeParam

	if router.hooks.RequestParseCompleted != nil {
		router.hooks.RequestParseCompleted(r, "DeleteTransactionsUUID")
	}

	return
}

func (router *TransactionsRouter) postTransaction(w http.ResponseWriter, r *http.Request) {
	var request PostTransactionRequest

	XSignature := r.Header.Get("x-signature")
	if XSignature != "" {
		request.header.XSignature = &XSignature
	}
	XFingerprint := r.Header.Get("x-fingerprint")
	if XFingerprint == "" {
		err := fmt.Errorf("x-fingerprint is required")

		request.ProcessingResult = RequestProcessingResult{error: err, typee: HeaderParseFailed}
		if router.hooks.RequestHeaderParseFailed != nil {
			router.hooks.RequestHeaderParseFailed(r, "postTransaction", "x-fingerprint", request.ProcessingResult)
		}

		return
	}

	if !fingerprintRegex.MatchString(XFingerprint) {
		err := fmt.Errorf("x-fingerprint not matched by the '[0-9a-fA-F]+' regex")

		request.ProcessingResult = RequestProcessingResult{error: err, typee: HeaderParseFailed}
		if router.hooks.RequestHeaderParseFailed != nil {
			router.hooks.RequestHeaderParseFailed(r, "postTransaction", "x-fingerprint", request.ProcessingResult)
		}

		return
	}

	request.header.XFingerprint = XFingerprint

	var (
		body      CreateTransactionRequest
		decodeErr error
	)
	decodeErr = json.NewDecoder(r.Body).Decode(&body)
	if decodeErr != nil {
		request.ProcessingResult = RequestProcessingResult{error: decodeErr, typee: BodyUnmarshalFailed}
		if router.hooks.RequestBodyUnmarshalFailed != nil {
			router.hooks.RequestBodyUnmarshalFailed(r, "postTransaction", request.ProcessingResult)
		}

		return
	}
	request.body = body

	request = router.parsePostTransactionRequest(r)

	response := router.service.PostTransaction(r.Context(), &request)
	response.WriteTo(w)
}

func (router *TransactionsRouter) parsePostTransactionRequest(r *http.Request) (request PostTransactionRequest) {
	request.ProcessingResult = RequestProcessingResult{typee: ParseSucceed}

	XSignature := r.Header.Get("x-signature")
	if XSignature != "" {
		request.header.XSignature = &XSignature
	}
	XFingerprint := r.Header.Get("x-fingerprint")
	if XFingerprint == "" {
		err := fmt.Errorf("x-fingerprint is required")

		request.ProcessingResult = RequestProcessingResult{error: err, typee: HeaderParseFailed}
		if router.hooks.RequestHeaderParseFailed != nil {
			router.hooks.RequestHeaderParseFailed(r, "PostTransaction", "x-fingerprint", request.ProcessingResult)
		}

		return
	}

	if !fingerprintRegex.MatchString(XFingerprint) {
		err := fmt.Errorf("x-fingerprint not matched by the '[0-9a-fA-F]+' regex")

		request.ProcessingResult = RequestProcessingResult{error: err, typee: HeaderParseFailed}
		if router.hooks.RequestHeaderParseFailed != nil {
			router.hooks.RequestHeaderParseFailed(r, "PostTransaction", "x-fingerprint", request.ProcessingResult)
		}

		return
	}

	request.header.XFingerprint = XFingerprint

	var (
		body      CreateTransactionRequest
		decodeErr error
	)
	decodeErr = json.NewDecoder(r.Body).Decode(&body)
	if decodeErr != nil {
		request.ProcessingResult = RequestProcessingResult{error: decodeErr, typee: BodyUnmarshalFailed}
		if router.hooks.RequestBodyUnmarshalFailed != nil {
			router.hooks.RequestBodyUnmarshalFailed(r, "PostTransaction", request.ProcessingResult)
		}

		return
	}
	request.body = body

	if router.hooks.RequestParseCompleted != nil {
		router.hooks.RequestParseCompleted(r, "PostTransaction")
	}

	return
}

func (router *TransactionsRouter) putTransaction(w http.ResponseWriter, r *http.Request) {
	var request PutTransactionRequest

	XSignature := r.Header.Get("x-signature")
	if XSignature != "" {
		request.header.XSignature = &XSignature
	}
	XFingerprint := r.Header.Get("x-fingerprint")
	if XFingerprint == "" {
		err := fmt.Errorf("x-fingerprint is required")

		request.ProcessingResult = RequestProcessingResult{error: err, typee: HeaderParseFailed}
		if router.hooks.RequestHeaderParseFailed != nil {
			router.hooks.RequestHeaderParseFailed(r, "putTransaction", "x-fingerprint", request.ProcessingResult)
		}

		return
	}

	if !fingerprintRegex.MatchString(XFingerprint) {
		err := fmt.Errorf("x-fingerprint not matched by the '[0-9a-fA-F]+' regex")

		request.ProcessingResult = RequestProcessingResult{error: err, typee: HeaderParseFailed}
		if router.hooks.RequestHeaderParseFailed != nil {
			router.hooks.RequestHeaderParseFailed(r, "putTransaction", "x-fingerprint", request.ProcessingResult)
		}

		return
	}

	request.header.XFingerprint = XFingerprint

	var (
		body      UpdateTransactionRequest
		decodeErr error
	)
	decodeErr = json.NewDecoder(r.Body).Decode(&body)
	if decodeErr != nil {
		request.ProcessingResult = RequestProcessingResult{error: decodeErr, typee: BodyUnmarshalFailed}
		if router.hooks.RequestBodyUnmarshalFailed != nil {
			router.hooks.RequestBodyUnmarshalFailed(r, "putTransaction", request.ProcessingResult)
		}

		return
	}
	request.body = body

	request = router.parsePutTransactionRequest(r)

	response := router.service.PutTransaction(r.Context(), &request)
	response.WriteTo(w)
}

func (router *TransactionsRouter) parsePutTransactionRequest(r *http.Request) (request PutTransactionRequest) {
	request.ProcessingResult = RequestProcessingResult{typee: ParseSucceed}

	XSignature := r.Header.Get("x-signature")
	if XSignature != "" {
		request.header.XSignature = &XSignature
	}
	XFingerprint := r.Header.Get("x-fingerprint")
	if XFingerprint == "" {
		err := fmt.Errorf("x-fingerprint is required")

		request.ProcessingResult = RequestProcessingResult{error: err, typee: HeaderParseFailed}
		if router.hooks.RequestHeaderParseFailed != nil {
			router.hooks.RequestHeaderParseFailed(r, "PutTransaction", "x-fingerprint", request.ProcessingResult)
		}

		return
	}

	if !fingerprintRegex.MatchString(XFingerprint) {
		err := fmt.Errorf("x-fingerprint not matched by the '[0-9a-fA-F]+' regex")

		request.ProcessingResult = RequestProcessingResult{error: err, typee: HeaderParseFailed}
		if router.hooks.RequestHeaderParseFailed != nil {
			router.hooks.RequestHeaderParseFailed(r, "PutTransaction", "x-fingerprint", request.ProcessingResult)
		}

		return
	}

	request.header.XFingerprint = XFingerprint

	var (
		body      UpdateTransactionRequest
		decodeErr error
	)
	decodeErr = json.NewDecoder(r.Body).Decode(&body)
	if decodeErr != nil {
		request.ProcessingResult = RequestProcessingResult{error: decodeErr, typee: BodyUnmarshalFailed}
		if router.hooks.RequestBodyUnmarshalFailed != nil {
			router.hooks.RequestBodyUnmarshalFailed(r, "PutTransaction", request.ProcessingResult)
		}

		return
	}
	request.body = body

	if router.hooks.RequestParseCompleted != nil {
		router.hooks.RequestParseCompleted(r, "PutTransaction")
	}

	return
}

type AuthService interface {
	PostBearerEndpoint(ctx context.Context, request *PostBearerEndpointRequest) *PostBearerEndpointResponse
	GetSecureEndpoint(ctx context.Context, request *GetSecureEndpointRequest) *GetSecureEndpointResponse
	GetSemiSecureEndpoint(ctx context.Context, request *GetSemiSecureEndpointRequest) *GetSemiSecureEndpointResponse
}

type AuthRouter struct {
	service    AuthService
	router     *chi.Mux
	hooks      *Hooks
	processors []securityProcessor
}

func NewAuthRouter(service AuthService, processors ...securityProcessor) *AuthRouter {
	router := chi.NewMux()
	instance := &AuthRouter{service: service, router: router, hooks: &Hooks{}, processors: processors}
	return instance
}

func (router *AuthRouter) postBearerEndpoint(w http.ResponseWriter, r *http.Request) {
	var request PostBearerEndpointRequest

	request = router.parsePostBearerEndpointRequest(r)

	response := router.service.PostBearerEndpoint(r.Context(), &request)
	response.WriteTo(w)
}

func (router *AuthRouter) parsePostBearerEndpointRequest(r *http.Request) (request PostBearerEndpointRequest) {
	request.ProcessingResult = RequestProcessingResult{typee: ParseSucceed}

	for _, processor := range router.processors {
		if processor.scheme == SecuritySchemeBearer {
			name, value, found := processor.extract(r)
			if !found {
				request.ProcessingResult = RequestProcessingResult{error: fmt.Errorf("security scheme not found"), typee: SecurityParseFailed}
				if router.hooks.RequestSecurityParseFailed != nil {
					router.hooks.RequestSecurityParseFailed(r, "PostBearerEndpoint", request.ProcessingResult)
				}
				return
			}

			if err := processor.handle(r, processor.scheme, name, value); err != nil {
				request.ProcessingResult = RequestProcessingResult{error: err, typee: SecurityCheckFailed}
				if router.hooks.RequestSecurityCheckFailed != nil {
					router.hooks.RequestSecurityCheckFailed(r, "PostBearerEndpoint", string(processor.scheme), request.ProcessingResult)
				}
				return
			}

			if router.hooks.RequestSecurityCheckCompleted != nil {
				router.hooks.RequestSecurityCheckCompleted(r, "PostBearerEndpoint", string(processor.scheme))
			}
			break
		}
	}

	if router.hooks.RequestParseCompleted != nil {
		router.hooks.RequestParseCompleted(r, "PostBearerEndpoint")
	}

	return
}

func (router *AuthRouter) getSecureEndpoint(w http.ResponseWriter, r *http.Request) {
	var request GetSecureEndpointRequest

	request = router.parseGetSecureEndpointRequest(r)

	response := router.service.GetSecureEndpoint(r.Context(), &request)
	response.WriteTo(w)
}

func (router *AuthRouter) parseGetSecureEndpointRequest(r *http.Request) (request GetSecureEndpointRequest) {
	request.ProcessingResult = RequestProcessingResult{typee: ParseSucceed}

	for _, processor := range router.processors {
		if processor.scheme == SecuritySchemeApiKeyAuth {
			name, value, found := processor.extract(r)
			if !found {
				request.ProcessingResult = RequestProcessingResult{error: fmt.Errorf("security scheme not found"), typee: SecurityParseFailed}
				if router.hooks.RequestSecurityParseFailed != nil {
					router.hooks.RequestSecurityParseFailed(r, "GetSecureEndpoint", request.ProcessingResult)
				}
				return
			}

			if err := processor.handle(r, processor.scheme, name, value); err != nil {
				request.ProcessingResult = RequestProcessingResult{error: err, typee: SecurityCheckFailed}
				if router.hooks.RequestSecurityCheckFailed != nil {
					router.hooks.RequestSecurityCheckFailed(r, "GetSecureEndpoint", string(processor.scheme), request.ProcessingResult)
				}
				return
			}

			if router.hooks.RequestSecurityCheckCompleted != nil {
				router.hooks.RequestSecurityCheckCompleted(r, "GetSecureEndpoint", string(processor.scheme))
			}
			break
		}
	}

	if router.hooks.RequestParseCompleted != nil {
		router.hooks.RequestParseCompleted(r, "GetSecureEndpoint")
	}

	return
}

func (router *AuthRouter) getSemiSecureEndpoint(w http.ResponseWriter, r *http.Request) {
	var request GetSemiSecureEndpointRequest

	request = router.parseGetSemiSecureEndpointRequest(r)

	response := router.service.GetSemiSecureEndpoint(r.Context(), &request)
	response.WriteTo(w)
}

func (router *AuthRouter) parseGetSemiSecureEndpointRequest(r *http.Request) (request GetSemiSecureEndpointRequest) {
	request.ProcessingResult = RequestProcessingResult{typee: ParseSucceed}

	if router.hooks.RequestParseCompleted != nil {
		router.hooks.RequestParseCompleted(r, "GetSemiSecureEndpoint")
	}

	return
}

type CallbacksService interface {
	PostCallbacksCallbackType(ctx context.Context, request *PostCallbacksCallbackTypeRequest) *PostCallbacksCallbackTypeResponse
}

type CallbacksRouter struct {
	service    CallbacksService
	router     *chi.Mux
	hooks      *Hooks
	processors []securityProcessor
}

func NewCallbacksRouter(service CallbacksService, processors ...securityProcessor) *CallbacksRouter {
	router := chi.NewMux()
	instance := &CallbacksRouter{service: service, router: router, hooks: &Hooks{}, processors: processors}
	return instance
}

func (router *CallbacksRouter) postCallbacksCallbackType(w http.ResponseWriter, r *http.Request) {
	var request PostCallbacksCallbackTypeRequest

	CallbackType := chi.URLParam(r, "callbackType")
	if CallbackType == "" {
		err := fmt.Errorf("callbackType is required")

		request.ProcessingResult = RequestProcessingResult{error: err, typee: PathParseFailed}
		if router.hooks.RequestPathParseFailed != nil {
			router.hooks.RequestPathParseFailed(r, "postCallbacksCallbackType", "callbackType", request.ProcessingResult)
		}

		return
	}

	request.path.CallbackType = CallbackType

	HasSmthStr := r.URL.Query().Get("hasSmth")
	HasSmth, err := strconv.ParseBool(HasSmthStr)
	if err != nil {
		request.ProcessingResult = RequestProcessingResult{error: err, typee: QueryParseFailed}
		if router.hooks.RequestQueryParseFailed != nil {
			router.hooks.RequestQueryParseFailed(r, "postCallbacksCallbackType", "hasSmth", request.ProcessingResult)
		}

		return
	}

	request.query.HasSmth = &HasSmth

	var (
		body      RawPayload
		decodeErr error
	)
	var (
		buf     interface{}
		ok      bool
		readErr error
	)
	if buf, readErr = io.ReadAll(r.Body); readErr == nil {
		if body, ok = buf.(RawPayload); !ok {
			decodeErr = errors.New("body is not []byte")
		}
	}
	if decodeErr != nil {
		request.ProcessingResult = RequestProcessingResult{error: decodeErr, typee: BodyUnmarshalFailed}
		if router.hooks.RequestBodyUnmarshalFailed != nil {
			router.hooks.RequestBodyUnmarshalFailed(r, "postCallbacksCallbackType", request.ProcessingResult)
		}

		return
	}
	request.body = body

	request = router.parsePostCallbacksCallbackTypeRequest(r)

	response := router.service.PostCallbacksCallbackType(r.Context(), &request)
	response.WriteTo(w)
}

func (router *CallbacksRouter) parsePostCallbacksCallbackTypeRequest(r *http.Request) (request PostCallbacksCallbackTypeRequest) {
	request.ProcessingResult = RequestProcessingResult{typee: ParseSucceed}

	for _, processor := range router.processors {
		if processor.scheme == SecuritySchemeCookie {
			name, value, found := processor.extract(r)
			if !found {
				request.ProcessingResult = RequestProcessingResult{error: fmt.Errorf("security scheme not found"), typee: SecurityParseFailed}
				if router.hooks.RequestSecurityParseFailed != nil {
					router.hooks.RequestSecurityParseFailed(r, "PostCallbacksCallbackType", request.ProcessingResult)
				}
				return
			}

			if err := processor.handle(r, processor.scheme, name, value); err != nil {
				request.ProcessingResult = RequestProcessingResult{error: err, typee: SecurityCheckFailed}
				if router.hooks.RequestSecurityCheckFailed != nil {
					router.hooks.RequestSecurityCheckFailed(r, "PostCallbacksCallbackType", string(processor.scheme), request.ProcessingResult)
				}
				return
			}

			if router.hooks.RequestSecurityCheckCompleted != nil {
				router.hooks.RequestSecurityCheckCompleted(r, "PostCallbacksCallbackType", string(processor.scheme))
			}
			break
		}
	}
	CallbackType := chi.URLParam(r, "callbackType")
	if CallbackType == "" {
		err := fmt.Errorf("callbackType is required")

		request.ProcessingResult = RequestProcessingResult{error: err, typee: PathParseFailed}
		if router.hooks.RequestPathParseFailed != nil {
			router.hooks.RequestPathParseFailed(r, "PostCallbacksCallbackType", "callbackType", request.ProcessingResult)
		}

		return
	}

	request.path.CallbackType = CallbackType

	HasSmthStr := r.URL.Query().Get("hasSmth")
	HasSmth, err := strconv.ParseBool(HasSmthStr)
	if err != nil {
		request.ProcessingResult = RequestProcessingResult{error: err, typee: QueryParseFailed}
		if router.hooks.RequestQueryParseFailed != nil {
			router.hooks.RequestQueryParseFailed(r, "PostCallbacksCallbackType", "hasSmth", request.ProcessingResult)
		}

		return
	}

	request.query.HasSmth = &HasSmth

	var (
		body      RawPayload
		decodeErr error
	)
	var (
		buf     interface{}
		ok      bool
		readErr error
	)
	if buf, readErr = io.ReadAll(r.Body); readErr == nil {
		if body, ok = buf.(RawPayload); !ok {
			decodeErr = errors.New("body is not []byte")
		}
	}
	if decodeErr != nil {
		request.ProcessingResult = RequestProcessingResult{error: decodeErr, typee: BodyUnmarshalFailed}
		if router.hooks.RequestBodyUnmarshalFailed != nil {
			router.hooks.RequestBodyUnmarshalFailed(r, "PostCallbacksCallbackType", request.ProcessingResult)
		}

		return
	}
	request.body = body

	if router.hooks.RequestParseCompleted != nil {
		router.hooks.RequestParseCompleted(r, "PostCallbacksCallbackType")
	}

	return
}

type Hooks struct {
	RequestSecurityParseFailed    func(*http.Request, string, RequestProcessingResult)
	RequestSecurityParseCompleted func(*http.Request, string)
	RequestSecurityCheckFailed    func(*http.Request, string, string, RequestProcessingResult)
	RequestSecurityCheckCompleted func(*http.Request, string, string)
	RequestBodyUnmarshalFailed    func(*http.Request, string, RequestProcessingResult)
	RequestHeaderParseFailed      func(*http.Request, string, string, RequestProcessingResult)
	RequestPathParseFailed        func(*http.Request, string, string, RequestProcessingResult)
	RequestQueryParseFailed       func(*http.Request, string, string, RequestProcessingResult)
	RequestBodyValidationFailed   func(*http.Request, string, RequestProcessingResult)
	RequestHeaderValidationFailed func(*http.Request, string, RequestProcessingResult)
	RequestPathValidationFailed   func(*http.Request, string, RequestProcessingResult)
	RequestQueryValidationFailed  func(*http.Request, string, RequestProcessingResult)
	RequestBodyUnmarshalCompleted func(*http.Request, string)
	RequestHeaderParseCompleted   func(*http.Request, string)
	RequestPathParseCompleted     func(*http.Request, string)
	RequestQueryParseCompleted    func(*http.Request, string)
	RequestParseCompleted         func(*http.Request, string)
	RequestProcessingCompleted    func(*http.Request, string)
	RequestRedirectStarted        func(*http.Request, string, string)
	ResponseBodyMarshalCompleted  func(*http.Request, string)
	ResponseBodyWriteCompleted    func(*http.Request, string, int)
	ResponseBodyMarshalFailed     func(http.ResponseWriter, *http.Request, string, error)
	ResponseBodyWriteFailed       func(*http.Request, string, int, error)
	ServiceCompleted              func(*http.Request, string)
}

type requestProcessingResultType uint8

const (
	BodyUnmarshalFailed requestProcessingResultType = iota + 1
	BodyValidationFailed
	HeaderParseFailed
	HeaderValidationFailed
	QueryParseFailed
	QueryValidationFailed
	PathParseFailed
	PathValidationFailed
	SecurityParseFailed
	SecurityCheckFailed
	ParseSucceed
)

type RequestProcessingResult struct {
	error error
	typee requestProcessingResultType
}

func NewRequestProcessingResult(t requestProcessingResultType, err error) RequestProcessingResult {
	return RequestProcessingResult{
		error: err,
		typee: t,
	}
}

func (r RequestProcessingResult) Type() requestProcessingResultType {
	return r.typee
}

func (r RequestProcessingResult) Err() error {
	return r.error
}

type response struct {
	body        interface{}
	contentType string
	statusCode  int
	headers     map[string]string
}

func (r *response) WriteTo(w http.ResponseWriter) {
	for key, value := range r.headers {
		w.Header().Set(key, value)
	}
	w.Header().Set("Content-Type", r.contentType)
	w.WriteHeader(r.statusCode)
	switch body := r.body.(type) {
	case string:
		w.Write([]byte(body))
	case []byte:
		w.Write(body)
	default:
		if r.body != nil {
			json.NewEncoder(w).Encode(r.body)
		}
	}
}

type AuthResponse struct {
	*response
}

func (r *AuthResponse) WriteTo(w http.ResponseWriter) {
	if r.response != nil {
		r.response.WriteTo(w)
	}
}

type CallbacksResponse struct {
	*response
}

func (r *CallbacksResponse) WriteTo(w http.ResponseWriter) {
	if r.response != nil {
		r.response.WriteTo(w)
	}
}

type TransactionsResponse struct {
	*response
}

func (r *TransactionsResponse) WriteTo(w http.ResponseWriter) {
	if r.response != nil {
		r.response.WriteTo(w)
	}
}

type PostBearerEndpointResponse struct {
	*response
}

func (r *PostBearerEndpointResponse) WriteTo(w http.ResponseWriter) {
	if r.response != nil {
		r.response.WriteTo(w)
	}
}

type GetSecureEndpointResponse struct {
	*response
}

func (r *GetSecureEndpointResponse) WriteTo(w http.ResponseWriter) {
	if r.response != nil {
		r.response.WriteTo(w)
	}
}

type GetSemiSecureEndpointResponse struct {
	*response
}

func (r *GetSemiSecureEndpointResponse) WriteTo(w http.ResponseWriter) {
	if r.response != nil {
		r.response.WriteTo(w)
	}
}

type PostCallbacksCallbackTypeResponse struct {
	*response
}

func (r *PostCallbacksCallbackTypeResponse) WriteTo(w http.ResponseWriter) {
	if r.response != nil {
		r.response.WriteTo(w)
	}
}

type PostTransactionResponse struct {
	*response
}

func (r *PostTransactionResponse) WriteTo(w http.ResponseWriter) {
	if r.response != nil {
		r.response.WriteTo(w)
	}
}

type PutTransactionResponse struct {
	*response
}

func (r *PutTransactionResponse) WriteTo(w http.ResponseWriter) {
	if r.response != nil {
		r.response.WriteTo(w)
	}
}

type DeleteTransactionsUUIDResponse struct {
	*response
}

func (r *DeleteTransactionsUUIDResponse) WriteTo(w http.ResponseWriter) {
	if r.response != nil {
		r.response.WriteTo(w)
	}
}

type PostTransactionStatus201Builder struct {
	response *response
}

func (b *PostTransactionStatus201Builder) Status() *PostTransaction201ContentTypeBuilder {
	b.response.statusCode = 201
	return &PostTransaction201ContentTypeBuilder{response: b.response}
}

type PostTransaction201ContentTypeBuilder struct {
	response *response
}

func (b *PostTransaction201ContentTypeBuilder) ApplicationJson() *PostTransaction201ApplicationJsonContentTypeBuilder {
	return &PostTransaction201ApplicationJsonContentTypeBuilder{response: b.response}
}

type PostTransaction201ApplicationJsonContentTypeBuilder struct {
	response *response
}

func (b *PostTransaction201ApplicationJsonContentTypeBuilder) PostTransactionApplicationJsonBodyBuilder(body interface{}) *PostTransaction201ApplicationJsonHeadersBuilder {
	b.response.body = body
	b.response.contentType = "application/json"
	return &PostTransaction201ApplicationJsonHeadersBuilder{response: b.response}
}

type PostTransaction201ApplicationJsonHeaders struct{}

type PostTransaction201ApplicationJsonHeadersBuilder struct {
	response *response
}

func (b *PostTransaction201ApplicationJsonHeadersBuilder) Headers() *PostTransactionResponse {
	// No headers to set
	return &PostTransactionResponse{response: b.response}
}

type PostTransactionStatus400Builder struct {
	response *response
}

func (b *PostTransactionStatus400Builder) Status() *PostTransaction400ContentTypeBuilder {
	b.response.statusCode = 400
	return &PostTransaction400ContentTypeBuilder{response: b.response}
}

type PostTransaction400ContentTypeBuilder struct {
	response *response
}

func (b *PostTransaction400ContentTypeBuilder) ApplicationJson() *PostTransaction400ApplicationJsonContentTypeBuilder {
	return &PostTransaction400ApplicationJsonContentTypeBuilder{response: b.response}
}

type PostTransaction400ApplicationJsonContentTypeBuilder struct {
	response *response
}

func (b *PostTransaction400ApplicationJsonContentTypeBuilder) PostTransactionApplicationJsonBodyBuilder(body interface{}) *PostTransaction400ApplicationJsonHeadersBuilder {
	b.response.body = body
	b.response.contentType = "application/json"
	return &PostTransaction400ApplicationJsonHeadersBuilder{response: b.response}
}

type PostTransaction400ApplicationJsonHeaders struct{}

type PostTransaction400ApplicationJsonHeadersBuilder struct {
	response *response
}

func (b *PostTransaction400ApplicationJsonHeadersBuilder) Headers() *PostTransactionResponse {
	// No headers to set
	return &PostTransactionResponse{response: b.response}
}

type PostTransactionStatus500Builder struct {
	response *response
}

func (b *PostTransactionStatus500Builder) Status() *PostTransaction500ContentTypeBuilder {
	b.response.statusCode = 500
	return &PostTransaction500ContentTypeBuilder{response: b.response}
}

type PostTransaction500ContentTypeBuilder struct {
	response *response
}

func (b *PostTransaction500ContentTypeBuilder) ApplicationJson() *PostTransaction500ApplicationJsonContentTypeBuilder {
	return &PostTransaction500ApplicationJsonContentTypeBuilder{response: b.response}
}

type PostTransaction500ApplicationJsonContentTypeBuilder struct {
	response *response
}

func (b *PostTransaction500ApplicationJsonContentTypeBuilder) PostTransactionApplicationJsonBodyBuilder(body interface{}) *PostTransaction500ApplicationJsonHeadersBuilder {
	b.response.body = body
	b.response.contentType = "application/json"
	return &PostTransaction500ApplicationJsonHeadersBuilder{response: b.response}
}

type PostTransaction500ApplicationJsonHeaders struct{}

type PostTransaction500ApplicationJsonHeadersBuilder struct {
	response *response
}

func (b *PostTransaction500ApplicationJsonHeadersBuilder) Headers() *PostTransactionResponse {
	// No headers to set
	return &PostTransactionResponse{response: b.response}
}

type PutTransactionStatus200Builder struct {
	response *response
}

func (b *PutTransactionStatus200Builder) Status() *PutTransaction200ContentTypeBuilder {
	b.response.statusCode = 200
	return &PutTransaction200ContentTypeBuilder{response: b.response}
}

type PutTransaction200ContentTypeBuilder struct {
	response *response
}

func (b *PutTransaction200ContentTypeBuilder) ApplicationJson() *PutTransaction200ApplicationJsonContentTypeBuilder {
	return &PutTransaction200ApplicationJsonContentTypeBuilder{response: b.response}
}

type PutTransaction200ApplicationJsonContentTypeBuilder struct {
	response *response
}

func (b *PutTransaction200ApplicationJsonContentTypeBuilder) PutTransactionApplicationJsonBodyBuilder(body interface{}) *PutTransaction200ApplicationJsonHeadersBuilder {
	b.response.body = body
	b.response.contentType = "application/json"
	return &PutTransaction200ApplicationJsonHeadersBuilder{response: b.response}
}

type PutTransaction200ApplicationJsonHeaders struct{}

type PutTransaction200ApplicationJsonHeadersBuilder struct {
	response *response
}

func (b *PutTransaction200ApplicationJsonHeadersBuilder) Headers() *PutTransactionResponse {
	// No headers to set
	return &PutTransactionResponse{response: b.response}
}

type PutTransactionStatus400Builder struct {
	response *response
}

func (b *PutTransactionStatus400Builder) Status() *PutTransaction400ContentTypeBuilder {
	b.response.statusCode = 400
	return &PutTransaction400ContentTypeBuilder{response: b.response}
}

type PutTransaction400ContentTypeBuilder struct {
	response *response
}

func (b *PutTransaction400ContentTypeBuilder) ApplicationJson() *PutTransaction400ApplicationJsonContentTypeBuilder {
	return &PutTransaction400ApplicationJsonContentTypeBuilder{response: b.response}
}

type PutTransaction400ApplicationJsonContentTypeBuilder struct {
	response *response
}

func (b *PutTransaction400ApplicationJsonContentTypeBuilder) PutTransactionApplicationJsonBodyBuilder(body interface{}) *PutTransaction400ApplicationJsonHeadersBuilder {
	b.response.body = body
	b.response.contentType = "application/json"
	return &PutTransaction400ApplicationJsonHeadersBuilder{response: b.response}
}

type PutTransaction400ApplicationJsonHeaders struct{}

type PutTransaction400ApplicationJsonHeadersBuilder struct {
	response *response
}

func (b *PutTransaction400ApplicationJsonHeadersBuilder) Headers() *PutTransactionResponse {
	// No headers to set
	return &PutTransactionResponse{response: b.response}
}

type PutTransactionStatus500Builder struct {
	response *response
}

func (b *PutTransactionStatus500Builder) Status() *PutTransaction500ContentTypeBuilder {
	b.response.statusCode = 500
	return &PutTransaction500ContentTypeBuilder{response: b.response}
}

type PutTransaction500ContentTypeBuilder struct {
	response *response
}

func (b *PutTransaction500ContentTypeBuilder) ApplicationJson() *PutTransaction500ApplicationJsonContentTypeBuilder {
	return &PutTransaction500ApplicationJsonContentTypeBuilder{response: b.response}
}

type PutTransaction500ApplicationJsonContentTypeBuilder struct {
	response *response
}

func (b *PutTransaction500ApplicationJsonContentTypeBuilder) PutTransactionApplicationJsonBodyBuilder(body interface{}) *PutTransaction500ApplicationJsonHeadersBuilder {
	b.response.body = body
	b.response.contentType = "application/json"
	return &PutTransaction500ApplicationJsonHeadersBuilder{response: b.response}
}

type PutTransaction500ApplicationJsonHeaders struct{}

type PutTransaction500ApplicationJsonHeadersBuilder struct {
	response *response
}

func (b *PutTransaction500ApplicationJsonHeadersBuilder) Headers() *PutTransactionResponse {
	// No headers to set
	return &PutTransactionResponse{response: b.response}
}

type DeleteTransactionsUUIDStatus200Builder struct {
	response *response
}

func (b *DeleteTransactionsUUIDStatus200Builder) Status() *DeleteTransactionsUUID200ContentTypeBuilder {
	b.response.statusCode = 200
	return &DeleteTransactionsUUID200ContentTypeBuilder{response: b.response}
}

type DeleteTransactionsUUID200ContentTypeBuilder struct {
	response *response
}

func (b *DeleteTransactionsUUID200ContentTypeBuilder) ApplicationJson() *DeleteTransactionsUUID200ApplicationJsonContentTypeBuilder {
	return &DeleteTransactionsUUID200ApplicationJsonContentTypeBuilder{response: b.response}
}

type DeleteTransactionsUUID200ApplicationJsonContentTypeBuilder struct {
	response *response
}

func (b *DeleteTransactionsUUID200ApplicationJsonContentTypeBuilder) DeleteTransactionsUUIDApplicationJsonBodyBuilder(body interface{}) *DeleteTransactionsUUID200ApplicationJsonHeadersBuilder {
	b.response.body = body
	b.response.contentType = "application/json"
	return &DeleteTransactionsUUID200ApplicationJsonHeadersBuilder{response: b.response}
}

type DeleteTransactionsUUID200ApplicationJsonHeaders struct {
	ContentEncoding string `json:"content-Encoding"`
}

type DeleteTransactionsUUID200ApplicationJsonHeadersBuilder struct {
	response *response
}

func (b *DeleteTransactionsUUID200ApplicationJsonHeadersBuilder) Headers(headers DeleteTransactionsUUID200ApplicationJsonHeaders) *DeleteTransactionsUUIDResponse {
	// Set headers in response
	if b.response.headers == nil {
		b.response.headers = make(map[string]string)
	}
	if headers.ContentEncoding != "" {
		b.response.headers["Content-Encoding"] = headers.ContentEncoding
	}
	return &DeleteTransactionsUUIDResponse{response: b.response}
}

type DeleteTransactionsUUIDStatus400Builder struct {
	response *response
}

func (b *DeleteTransactionsUUIDStatus400Builder) Status() *DeleteTransactionsUUID400ContentTypeBuilder {
	b.response.statusCode = 400
	return &DeleteTransactionsUUID400ContentTypeBuilder{response: b.response}
}

type DeleteTransactionsUUID400ContentTypeBuilder struct {
	response *response
}

func (b *DeleteTransactionsUUID400ContentTypeBuilder) ApplicationJson() *DeleteTransactionsUUID400ApplicationJsonContentTypeBuilder {
	return &DeleteTransactionsUUID400ApplicationJsonContentTypeBuilder{response: b.response}
}

type DeleteTransactionsUUID400ApplicationJsonContentTypeBuilder struct {
	response *response
}

func (b *DeleteTransactionsUUID400ApplicationJsonContentTypeBuilder) DeleteTransactionsUUIDApplicationJsonBodyBuilder(body interface{}) *DeleteTransactionsUUID400ApplicationJsonHeadersBuilder {
	b.response.body = body
	b.response.contentType = "application/json"
	return &DeleteTransactionsUUID400ApplicationJsonHeadersBuilder{response: b.response}
}

type DeleteTransactionsUUID400ApplicationJsonHeaders struct{}

type DeleteTransactionsUUID400ApplicationJsonHeadersBuilder struct {
	response *response
}

func (b *DeleteTransactionsUUID400ApplicationJsonHeadersBuilder) Headers() *DeleteTransactionsUUIDResponse {
	// No headers to set
	return &DeleteTransactionsUUIDResponse{response: b.response}
}

type PostBearerEndpointStatus200Builder struct {
	response *response
}

func (b *PostBearerEndpointStatus200Builder) Status() *PostBearerEndpoint200ContentTypeBuilder {
	b.response.statusCode = 200
	return &PostBearerEndpoint200ContentTypeBuilder{response: b.response}
}

type PostBearerEndpoint200ContentTypeBuilder struct {
	response *response
}

func (b *PostBearerEndpoint200ContentTypeBuilder) ApplicationJson() *PostBearerEndpoint200ApplicationJsonContentTypeBuilder {
	return &PostBearerEndpoint200ApplicationJsonContentTypeBuilder{response: b.response}
}

type PostBearerEndpoint200ApplicationJsonContentTypeBuilder struct {
	response *response
}

func (b *PostBearerEndpoint200ApplicationJsonContentTypeBuilder) PostBearerEndpointApplicationJsonBodyBuilder(body interface{}) *PostBearerEndpoint200ApplicationJsonHeadersBuilder {
	b.response.body = body
	b.response.contentType = "application/json"
	return &PostBearerEndpoint200ApplicationJsonHeadersBuilder{response: b.response}
}

type PostBearerEndpoint200ApplicationJsonHeaders struct{}

type PostBearerEndpoint200ApplicationJsonHeadersBuilder struct {
	response *response
}

func (b *PostBearerEndpoint200ApplicationJsonHeadersBuilder) Headers() *PostBearerEndpointResponse {
	// No headers to set
	return &PostBearerEndpointResponse{response: b.response}
}

type PostBearerEndpointStatus401Builder struct {
	response *response
}

func (b *PostBearerEndpointStatus401Builder) Status() *PostBearerEndpoint401ContentTypeBuilder {
	b.response.statusCode = 401
	return &PostBearerEndpoint401ContentTypeBuilder{response: b.response}
}

type PostBearerEndpoint401ContentTypeBuilder struct {
	response *response
}

type GetSecureEndpointStatus200Builder struct {
	response *response
}

func (b *GetSecureEndpointStatus200Builder) Status() *GetSecureEndpoint200ContentTypeBuilder {
	b.response.statusCode = 200
	return &GetSecureEndpoint200ContentTypeBuilder{response: b.response}
}

type GetSecureEndpoint200ContentTypeBuilder struct {
	response *response
}

func (b *GetSecureEndpoint200ContentTypeBuilder) ApplicationJson() *GetSecureEndpoint200ApplicationJsonContentTypeBuilder {
	return &GetSecureEndpoint200ApplicationJsonContentTypeBuilder{response: b.response}
}

type GetSecureEndpoint200ApplicationJsonContentTypeBuilder struct {
	response *response
}

func (b *GetSecureEndpoint200ApplicationJsonContentTypeBuilder) GetSecureEndpointApplicationJsonBodyBuilder(body interface{}) *GetSecureEndpoint200ApplicationJsonHeadersBuilder {
	b.response.body = body
	b.response.contentType = "application/json"
	return &GetSecureEndpoint200ApplicationJsonHeadersBuilder{response: b.response}
}

type GetSecureEndpoint200ApplicationJsonHeaders struct{}

type GetSecureEndpoint200ApplicationJsonHeadersBuilder struct {
	response *response
}

func (b *GetSecureEndpoint200ApplicationJsonHeadersBuilder) Headers() *GetSecureEndpointResponse {
	// No headers to set
	return &GetSecureEndpointResponse{response: b.response}
}

type GetSecureEndpointStatus401Builder struct {
	response *response
}

func (b *GetSecureEndpointStatus401Builder) Status() *GetSecureEndpoint401ContentTypeBuilder {
	b.response.statusCode = 401
	return &GetSecureEndpoint401ContentTypeBuilder{response: b.response}
}

type GetSecureEndpoint401ContentTypeBuilder struct {
	response *response
}

type GetSemiSecureEndpointStatus200Builder struct {
	response *response
}

func (b *GetSemiSecureEndpointStatus200Builder) Status() *GetSemiSecureEndpoint200ContentTypeBuilder {
	b.response.statusCode = 200
	return &GetSemiSecureEndpoint200ContentTypeBuilder{response: b.response}
}

type GetSemiSecureEndpoint200ContentTypeBuilder struct {
	response *response
}

func (b *GetSemiSecureEndpoint200ContentTypeBuilder) ApplicationJson() *GetSemiSecureEndpoint200ApplicationJsonContentTypeBuilder {
	return &GetSemiSecureEndpoint200ApplicationJsonContentTypeBuilder{response: b.response}
}

type GetSemiSecureEndpoint200ApplicationJsonContentTypeBuilder struct {
	response *response
}

func (b *GetSemiSecureEndpoint200ApplicationJsonContentTypeBuilder) GetSemiSecureEndpointApplicationJsonBodyBuilder(body interface{}) *GetSemiSecureEndpoint200ApplicationJsonHeadersBuilder {
	b.response.body = body
	b.response.contentType = "application/json"
	return &GetSemiSecureEndpoint200ApplicationJsonHeadersBuilder{response: b.response}
}

type GetSemiSecureEndpoint200ApplicationJsonHeaders struct{}

type GetSemiSecureEndpoint200ApplicationJsonHeadersBuilder struct {
	response *response
}

func (b *GetSemiSecureEndpoint200ApplicationJsonHeadersBuilder) Headers() *GetSemiSecureEndpointResponse {
	// No headers to set
	return &GetSemiSecureEndpointResponse{response: b.response}
}

type GetSemiSecureEndpointStatus400Builder struct {
	response *response
}

func (b *GetSemiSecureEndpointStatus400Builder) Status() *GetSemiSecureEndpoint400ContentTypeBuilder {
	b.response.statusCode = 400
	return &GetSemiSecureEndpoint400ContentTypeBuilder{response: b.response}
}

type GetSemiSecureEndpoint400ContentTypeBuilder struct {
	response *response
}

type PostCallbacksCallbackTypeStatus307Builder struct {
	response *response
}

func (b *PostCallbacksCallbackTypeStatus307Builder) Status() *PostCallbacksCallbackType307ContentTypeBuilder {
	b.response.statusCode = 307
	return &PostCallbacksCallbackType307ContentTypeBuilder{response: b.response}
}

type PostCallbacksCallbackType307ContentTypeBuilder struct {
	response *response
}

type PostCallbacksCallbackTypeStatus200Builder struct {
	response *response
}

func (b *PostCallbacksCallbackTypeStatus200Builder) Status() *PostCallbacksCallbackType200ContentTypeBuilder {
	b.response.statusCode = 200
	return &PostCallbacksCallbackType200ContentTypeBuilder{response: b.response}
}

type PostCallbacksCallbackType200ContentTypeBuilder struct {
	response *response
}

func (b *PostCallbacksCallbackType200ContentTypeBuilder) ApplicationOctetStream() *PostCallbacksCallbackType200ApplicationOctetStreamContentTypeBuilder {
	return &PostCallbacksCallbackType200ApplicationOctetStreamContentTypeBuilder{response: b.response}
}

type PostCallbacksCallbackType200ApplicationOctetStreamContentTypeBuilder struct {
	response *response
}

func (b *PostCallbacksCallbackType200ApplicationOctetStreamContentTypeBuilder) PostCallbacksCallbackTypeApplicationOctetStreamBodyBuilder(body interface{}) *PostCallbacksCallbackType200ApplicationOctetStreamHeadersBuilder {
	b.response.body = body
	b.response.contentType = "application/octet-stream"
	return &PostCallbacksCallbackType200ApplicationOctetStreamHeadersBuilder{response: b.response}
}

type PostCallbacksCallbackType200ApplicationOctetStreamHeaders struct {
	XJwsSignature string `json:"x-jws-signature"`
	SetCookie     string `json:"set-Cookie"`
}

type PostCallbacksCallbackType200ApplicationOctetStreamHeadersBuilder struct {
	response *response
}

func (b *PostCallbacksCallbackType200ApplicationOctetStreamHeadersBuilder) Headers(headers PostCallbacksCallbackType200ApplicationOctetStreamHeaders) *PostCallbacksCallbackTypeResponse {
	// Set headers in response
	if b.response.headers == nil {
		b.response.headers = make(map[string]string)
	}
	if headers.SetCookie != "" {
		b.response.headers["Set-Cookie"] = headers.SetCookie
	}
	if headers.XJwsSignature != "" {
		b.response.headers["x-jws-signature"] = headers.XJwsSignature
	}
	return &PostCallbacksCallbackTypeResponse{response: b.response}
}

type PostBearerEndpointResponseInterface interface {
	WriteTo(http.ResponseWriter)
}

type GetSecureEndpointResponseInterface interface {
	WriteTo(http.ResponseWriter)
}

type GetSemiSecureEndpointResponseInterface interface {
	WriteTo(http.ResponseWriter)
}

type PostCallbacksCallbackTypeResponseInterface interface {
	WriteTo(http.ResponseWriter)
}

type PostTransactionResponseInterface interface {
	WriteTo(http.ResponseWriter)
}

type PutTransactionResponseInterface interface {
	WriteTo(http.ResponseWriter)
}

type DeleteTransactionsUUIDResponseInterface interface {
	WriteTo(http.ResponseWriter)
}

type GetSemiSecureEndpointRequest struct {
	ProcessingResult RequestProcessingResult
}

type PostTransactionRequest struct {
	header struct {
		XSignature   *string `json:"x-signature"`
		XFingerprint string  `json:"x-fingerprint"`
	}
	body             CreateTransactionRequest
	ProcessingResult RequestProcessingResult
}

type PutTransactionRequest struct {
	header struct {
		XSignature   *string `json:"x-signature"`
		XFingerprint string  `json:"x-fingerprint"`
	}
	body             UpdateTransactionRequest
	ProcessingResult RequestProcessingResult
}

type DeleteTransactionsUUIDRequest struct {
	header struct {
		XSignature   *string `json:"x-signature"`
		XFingerprint string  `json:"x-fingerprint"`
	}
	path struct {
		UUID       string `json:"uuid"`
		RegexParam string `json:"regexParam"`
	}
	query struct {
		TimeParam *time.Time `json:"timeParam"`
	}
	ProcessingResult RequestProcessingResult
}

type PostBearerEndpointRequest struct {
	ProcessingResult RequestProcessingResult
}

type PostCallbacksCallbackTypeRequest struct {
	path struct {
		CallbackType string `json:"callbackType"`
	}
	query struct {
		HasSmth *bool `json:"hasSmth"`
	}
	body             RawPayload
	ProcessingResult RequestProcessingResult
}

type GetSecureEndpointRequest struct {
	ProcessingResult RequestProcessingResult
}

type SecurityScheme string

const (
	SecuritySchemeBearer     SecurityScheme = "Bearer"
	SecuritySchemeCookie     SecurityScheme = "Cookie"
	SecuritySchemeApiKeyAuth SecurityScheme = "ApiKeyAuth"
	SecuritySchemeBasic      SecurityScheme = "Basic"
)

type securityProcessor struct {
	scheme  SecurityScheme
	extract func(r *http.Request) (string, string, bool)
	handle  func(r *http.Request, scheme SecurityScheme, name string, value string) error
}

var SecuritySchemeExtractors = map[SecurityScheme]func(r *http.Request) (string, string, bool){
	SecuritySchemeBearer: func(r *http.Request) (string, string, bool) {
		value := r.Header.Get("Authorization")
		return "Authorization", value, value != ""
	},
	SecuritySchemeCookie: func(r *http.Request) (string, string, bool) {
		cookie, err := r.Cookie("JSESSIONID")
		if err != nil {
			return "", "", false
		}
		return "JSESSIONID", cookie.Value, true
	},
	SecuritySchemeApiKeyAuth: func(r *http.Request) (string, string, bool) {
		value := r.Header.Get("X-API-Key")
		return "X-API-Key", value, value != ""
	},
	SecuritySchemeBasic: func(r *http.Request) (string, string, bool) {
		value := r.Header.Get("Authorization")

		if !strings.HasPrefix(value, "Bearer ") {
			return "", "", false
		}

		value = value[7:]

		return "Authorization", value, value != ""
	}}
